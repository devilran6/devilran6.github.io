<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devilran🥝</title>
  
  
  <link href="https://devilran6.github.io/atom.xml" rel="self"/>
  
  <link href="https://devilran6.github.io/"/>
  <updated>2024-04-05T10:00:00.000Z</updated>
  <id>https://devilran6.github.io/</id>
  
  <author>
    <name>Devilran🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【往事随风】2 “我不停奔跑，只为追上那个被寄予厚望的自己”</title>
    <link href="https://devilran6.github.io/posts/e3c70f2a.html"/>
    <id>https://devilran6.github.io/posts/e3c70f2a.html</id>
    <published>2024-04-05T10:00:00.000Z</published>
    <updated>2024-04-05T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV18h4y1d7qb/?spm_id_from=333.788&amp;vd_source=664d223fe65c6706d11206b7416f5b92">“记录的意义，历久弥新”|教书琐记频道十万粉丝总结视频</a></p><p>这两天刷视频刷到了这位在浙江教书老师的课堂记录，<a href="https://www.bilibili.com/video/BV19z421o7Wf/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click&amp;vd_source=664d223fe65c6706d11206b7416f5b92"> “我不停奔跑，只为追上那个被寄予厚望的自己”|《项脊轩志》课堂实录</a>。起初看到前半句“我不停奔跑，只为追上那个寄予厚望的自己”并没有强烈点进去的欲望，感觉是一个鸡汤类型的视频文段，是什么引起我极大的好奇心呢？是紧接着的后半句“《项脊轩志》课堂实录”。</p><p>后半句仅仅是讲述了视频的主要内容，吸引我的是，我自认为是知道《项脊轩志》的（高中时期要求反复背诵的一篇文章，虽然现在不能从头到尾流畅的背诵下来，但也能大致的给出上句，说出下句，知晓语句的含义）。但是在我的脑海中，这篇文章和前面的“我不停奔跑，只为追上那个被寄予厚望的自己”，建立不了丝毫的联系，这种陌生与熟悉的交织感激发了我强烈的探索欲!</p><blockquote><p>回过头来看，是当时的我这篇文章学的过于肤浅，关注的只是表面的文字游戏罢了。存在记忆中的仅仅是如何学习文言文，而不是从文言文中学到什么。已经记不太清当时在学校老师是如何讲述的这篇文章了。但要我想必讲的也是极好的，在高中时期的两位老师和一段百家饭的经历中，都各具特色，颇有文学气息，总是能引发很多额外的思考，《呐喊》前言的详细导读，《红楼梦》的深度拓展、小人物的解读… 想起有段时间我还沉迷进了《蒋勋说红楼梦》</p></blockquote><div align="center">7 岁 -> 入塾就学<br>8 岁 -> 母亲亡故<br>15 岁 -> 束发读书轩中<br>16 岁 -> 祖母亡故<br>18 岁 -> 写《项脊轩志》<br>20 岁 -> 考中秀才<br>23 岁 -> 与魏氏结婚<br>28 岁 -> 妻魏氏亡故<br>31 岁 -> 续《项脊轩志》<br>35 岁 -> 考中举人<br>60 岁 -> 考中进士<br>66 岁 -> 去世<br></div><p>「吾少闻先考之言，吾家自高曾以来，累世未尝分异。传至于今，先考所生吾兄弟姊五人，吾遵父存日遗言，切切不能忘也。为吾子孙，而私其妻子求析生者，以为不孝，不可以列于归氏。」<br>———— 归有光《归氏世谱后》</p><p>「归氏至于有光之生，而日益衰。…率百人而聚，无一人知学者；率十人而学，无一人知礼义者」<br>———— 归有光《家谱记》</p><p>为了能将这个分崩离析的家庭聚合起来，需要一个德高望重、能重振家族的主心骨。在古代，是去考科举。从小起，如此重要的担子便落到了归有光的身上。</p><p>这一路上，有着母亲的关怀、祖母的期待、妻子的信任。<br>“儿之成，则可待乎!”<br>“孺人中夜觉寝，促有光暗诵《孝经》，即熟读，无一字龃龉，乃喜。”<br>“吾日观君，殆非今世人。丈夫当自立，何忧目前贫苦乎。”</p><p>可到他 31 岁续写《项脊轩志》，完整最后两段的时，经历的是幼年丧母，中年丧妻，科举一事无成，家庭分崩离析。面对的是“庭有枇杷树，吾妻死之年所手植也，今已亭亭如盖矣”物是人非的场景。他没有做到围绕在在家族重担、至亲期许、个人心志之中的“考取功名”。当时的他得有莫大的惆怅啊!!</p><p>可他仍在三年又三年的科举中奔跑，直到又经过三十余载才考中进士，而这时的他已经 60 岁了。在古代，可谓年迈不堪。他完成了少年时期对他的所有期许，但是很快在 66 岁的时候离开了人世… 多么一个充满遗憾，令人惋惜的故事。</p>]]></content>
    
    
    <summary type="html">《项脊轩志》有感</summary>
    
    
    
    <category term="往事随风" scheme="https://devilran6.github.io/categories/%E5%BE%80%E4%BA%8B%E9%9A%8F%E9%A3%8E/"/>
    
    
    <category term="项脊轩志" scheme="https://devilran6.github.io/tags/%E9%A1%B9%E8%84%8A%E8%BD%A9%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="https://devilran6.github.io/posts/a4d4b8b8.html"/>
    <id>https://devilran6.github.io/posts/a4d4b8b8.html</id>
    <published>2024-04-03T16:00:00.000Z</published>
    <updated>2024-04-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Yield</h1>]]></content>
    
    
    <summary type="html">Python</summary>
    
    
    
    <category term="Coding" scheme="https://devilran6.github.io/categories/Coding/"/>
    
    
    <category term="python" scheme="https://devilran6.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Cpp</title>
    <link href="https://devilran6.github.io/posts/f2a7e241.html"/>
    <id>https://devilran6.github.io/posts/f2a7e241.html</id>
    <published>2024-04-03T15:00:00.000Z</published>
    <updated>2024-04-03T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>数组</h1><p>数组是如何存在内存中的？<br>不同类型的指针的大小是如何增加的？</p><p><img src="../../assets/Pasted%20image%2020240403231611.png" alt=""></p><p>（照片取自 <a href="https://www.bilibili.com/video/BV1EW411u7th?p=14&amp;vd_source=664d223fe65c6706d11206b7416f5b92">Crash Course Computer Science P14</a>）</p>]]></content>
    
    
    <summary type="html">Cpp</summary>
    
    
    
    <category term="Coding" scheme="https://devilran6.github.io/categories/Coding/"/>
    
    
    <category term="cpp" scheme="https://devilran6.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.S081】 Lab3-Page Tables(2022)</title>
    <link href="https://devilran6.github.io/posts/f0420036.html"/>
    <id>https://devilran6.github.io/posts/f0420036.html</id>
    <published>2024-04-03T01:00:00.000Z</published>
    <updated>2024-04-03T01:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程地址：<a href="https://pdos.csail.mit.edu/6.S081/2022/schedule.html">https://pdos.csail.mit.edu/6.S081/2022/schedule.html</a><br>Lab 地址：<a href="https://pdos.csail.mit.edu/6.S081/2022/labs/pgtbl.html">https://pdos.csail.mit.edu/6.S081/2022/labs/pgtbl.html</a><br>我的代码地址：<a href="https://github.com/devilran6/devilran-xv6/tree/pgtbl">https://github.com/devilran6/devilran-xv6/tree/pgtbl</a><br>Commits：<a href="https://github.com/devilran6/devilran-xv6/commits/pgtbl/">https://github.com/devilran6/devilran-xv6/commits/pgtbl/</a></p></blockquote><h2 id="实验总结">实验总结</h2><p>Lab 3 完成时间约 10 h</p><p><strong>一些失误</strong></p><p>为什么从 lab 3 的题目上我特意写了 2022 呢？<br>是因为我之前因为 2020 版本的代码编译不成功，所以一直用的是 2022 版本的代码。<br>但是我一直是按照 2020 版本的实验做的，导致实验一直卡主😭😭😭</p><p><strong>Lab 3-1 Speed up system calls (easy)</strong></p><p>通过实现一个用户态和内核态都能访问的空间，进而将一些内核数据保存在此处，从而使得一些操作不用进行用户内核的切换，进行加速。</p><p>这个实验能感受到通过&quot;空间换时间&quot;的小 trick 来减少重复的不必要操作，实现操作系统的加速中的精妙!!</p><p><strong>Lab 3-2 Print a page table (easy)</strong></p><p>实现一个输出页表的函数。</p><p>这个实验不是很难，参考 <code>freewalk</code> 函数就很好写啦</p><p>主要的点在于：</p><ul><li>PTE 的三级页表机制</li><li>如何通过权限位区分是否为叶子节点</li></ul><p><strong>Lab 3-3 Detecting which pages have been accessed (hard)</strong></p><p>实现查看一段页表是否被访问过的系统调用。</p><p>这个实验不需要在很多个地方进行代码操作，只需要在内核系统调用函数处进行添加代码。<br>很好的实现了，只给你接口，具体实现代码自行随意的理念!!</p><p>主要是要了解内核和用户之间数据是如何传递的 – 需要用过 <code>argint</code> <code>argaddr</code> <code>copyin</code> <code>copyout</code> 等函数进行传递<br>传递如此复杂的原因是，内核和用户之间进行的强隔离!!</p><h2 id="Speed-up-system-calls-easy">Speed up system calls (easy)</h2><p>操作系统通过将 user 和 kernel 中的只读数据变成共享数据，这样将会消除执行这些系统调用时的内核交叉的需要，此任务将优化 xv6 中的 <code>ugetpid()</code> 。</p><blockquote><p>When each process is created, map one read-only page at <code>USYSCALL</code> (a virtual address defined in memlayout.h).</p><p>At the start of this page, store a struct usyscall (also defined in memlayout.h), and initialize it to store the PID of the current process.</p><p>For this lab, ugetpid() has been provided on the userspace side and will automatically use the USYSCALL mapping.</p><p>You will receive full credit for this part of the lab if the ugetpid test case passes when running pgtbltest.</p></blockquote><p>关于 <code>memlayout.h</code></p><p><img src="../../assets/image-20240402184551330.png" alt="|500"></p><h3 id="具体实施">具体实施</h3><h4 id="Step-1：创建指针">Step 1：创建指针</h4><p>首先在 <code>proc.h</code> 中的 <code>PCB</code> 中添加一个 <code>usyscall</code> 的指针</p><p><img src="../../assets/image-20240402143659816.png" alt=""></p><h4 id="Step-2：allocate">Step 2：allocate</h4><p>在 <code>proc.c</code> 中的 <code>allocproc()</code> 给 <code>p-&gt;usyscall</code> 指针分配一个物理页面，并将 <code>pid</code> 的值放进去</p><p><img src="../../assets/image-20240402184639767.png" alt=""></p><h4 id="Step-3：创建映射">Step 3：创建映射</h4><p><s>在 <code>memlayout.h</code> 中添加 <code>#define LAB_PGTBL</code>（感觉这里应该添加在 <code>defs.h</code> 中，但是 k添加了没作用不知道为什么）</s></p><p>在 Makefile 中已经添加好了 <code>-DLAB_PGTBL</code> 编译选项，所以这里不需要添加，最开始没显示是因为 vscode 不会显示出 Makefile 中的宏<br><img src="../../assets/image-20240402143023943.png" alt=""></p><p>在 <code>proc.c</code> 中的 <code>proc_pagetable()</code> 里面通过 <code>mappages()</code> 添加映射<br>!! 注意权限要有 <code>PTE_U</code> 表示在用户态可以访问</p><p><img src="../../assets/image-20240402144734389.png" alt=""></p><h4 id="Step-4：清除">Step 4：清除</h4><p>在 <code>proc.c</code> 中<br>分别在 <code>proc_freepagetable()</code> 和 <code>freeproc()</code> 中清除映射和 <code>p-&gt;usyscall</code></p><p><img src="../../assets/image-20240402145120732.png" alt=""></p><p><img src="../../assets/image-20240402185002485.png" alt=""></p><h3 id="运行结果">运行结果</h3><p><img src="../../assets/image-20240402185508366.png" alt=""></p><h3 id="注意">注意</h3><p>在 <code>allocproc()</code> 中添加的代码分配 <code>usyscall</code> 页面如果放到分配 <code>user page table</code> 后面的话，会出现内存问题</p><blockquote><p>但还没想明白为什么？</p></blockquote><p><img src="../../assets/image-20240402184338465.png" alt=""></p><h2 id="Print-a-page-table-easy">Print a page table (easy)</h2><blockquote><p>Define a function called <code>vmprint()</code>.</p><p>It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below.</p><p>Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in <code>exec.c</code> just before the return argc, to print the first process’s page table.</p><p>You receive full credit for this part of the lab if you pass the pte printout test of make grade.</p></blockquote><p>实现一个可视化页表的函数，效果如下</p><p><img src="../../assets/image-20240402191422805.png" alt=""></p><ul><li>Hint<ul><li>在 <code>kernel/vm.c</code> 中创建 <code>vmprint()</code></li><li>使用在 <code>kernel/riscv.h</code> 中最底部的一些 macro</li><li>从 <code>freewalk</code> 中获得一些启发</li><li>在 <code>kernel/defs.h</code> 中声明 <code>vmprint()</code>，从而 <code>exec.c</code> 函数中可以对其调用</li><li>用 <code>%p</code> 来输出 64 bits 的 PTE</li></ul></li></ul><h3 id="准备">准备</h3><p>在 <code>riscv.h</code> 中声明的一些宏</p><p><img src="../../assets/image-20240402191704442.png" alt=""></p><p><code>freewalk</code> 函数<br>注意写的注释，使用 <code>freewalk</code> 前，需要先将叶子节点进行释放。<br>从代码也可以看出，对叶子节点没有操作（就没有叶子节点部分的 <code>if</code> 分支）</p><p><img src="../../assets/image-20240402192419777.png" alt=""></p><h3 id="具体实施-2">具体实施</h3><h4 id="Step-1-创建并声明函数">Step 1: 创建并声明函数</h4><p>在 <code>vm.c</code> 中创建 <code>vmprint</code> ，和一个辅助函数 <code>vmprint_helper</code><br>辅助函数用于更好的递归，传递层数<br><img src="../../assets/image-20240402202733431.png" alt=""></p><p>声明函数<br><img src="../../assets/image-20240402194549874.png" alt=""></p><h4 id="Step-2-实现具体函数">Step 2: 实现具体函数</h4><p><img src="../../assets/image-20240402202700458.png" alt=""></p><h4 id="Step-3：输出启动进程页表">Step 3：输出启动进程页表</h4><p>Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in <code>exec.c</code> just before the <code>return argc</code>, to print the first process’s page table.</p><p><img src="../../assets/image-20240402195905350.png" alt=""></p><h3 id="运行结果-2">运行结果</h3><p><img src="../../assets/image-20240402202638791.png" alt=""></p><h3 id="注意-2">注意</h3><p>第一遍写完的时候发现没有后面的 <code>$</code> 输出了。<br>发现是在递归查看的时候把页表清零了，没有了映射可不是啥都干不成了🤣🤣🤣</p><p><img src="../../assets/image-20240402202325205.png" alt=""></p><h2 id="Detecting-which-pages-have-been-accessed-hard">Detecting which pages have been accessed (hard)</h2><blockquote><p>Your job is to implement pgaccess(), a system call that reports which pages have been accessed.</p><p>The system call takes three arguments.</p><p>First, it takes the starting virtual address of the first user page to check.<br>Second, it takes the number of pages to check.<br>Finally, it takes a <strong>user address</strong> to a buffer to store the results into a bitmask (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit).</p><p>You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p></blockquote><p>完善一个新的系统调用 <code>pgaccess</code> 的代码，其用于查看一段页表有没有被使用过（即 PTE 中的 <code>PTE_A</code> 位是否为 1）</p><ul><li>接受三个参数<ul><li>要查看的页表首地址</li><li>要连续查多少个页表</li><li>一个地址，返回值将放到这个地址里</li></ul></li></ul><h3 id="准备-2">准备</h3><h4 id="Walk-函数">Walk 函数</h4><p>查询虚拟地址对应的页表条目</p><ul><li>参数 1：页表</li><li>参数 2：虚拟地址</li><li>参数 3：是否分配，即当没查到虚拟地址对应的页表条目时，是否要为其分配一段空间</li></ul><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the address of the PTE in page table pagetable</span></span><br><span class="line"><span class="comment">// that corresponds to virtual address va.  If alloc!=0,</span></span><br><span class="line"><span class="comment">// create any required page-table pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The risc-v Sv39 scheme has three levels of page-table</span></span><br><span class="line"><span class="comment">// pages. A page-table page contains 512 64-bit PTEs.</span></span><br><span class="line"><span class="comment">// A 64-bit virtual address is split into five fields:</span></span><br><span class="line"><span class="comment">//   39..63 -- must be zero.</span></span><br><span class="line"><span class="comment">//   30..38 -- 9 bits of level-2 index.</span></span><br><span class="line"><span class="comment">//   21..29 -- 9 bits of level-1 index.</span></span><br><span class="line"><span class="comment">//   12..20 -- 9 bits of level-0 index.</span></span><br><span class="line"><span class="comment">//    0..11 -- 12 bits of byte offset within the page.</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA)</span><br><span class="line">        panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">        <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_V) &#123;</span><br><span class="line">            pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!alloc || (pagetable = (<span class="type">pde_t</span> *)kalloc()) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">            *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Argint-和-Argaddr-函数">Argint 和 Argaddr 函数</h4><p>用于在内核态时读取用户态传入的参数，具体实现会调用 <code>argraw</code> 来读取将用户态寄存器存到的 <code>trapframe</code>。</p><ul><li>参数 1：表示查找第几个传入参数</li><li>参数 2：接受参数地址</li></ul><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span> &#123;</span><br><span class="line">    *ip = argraw(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span> &#123;</span><br><span class="line">    *ip = argraw(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Copyin-和-Copyout-函数">Copyin 和 Copyout 函数</h4><p>用于将内核态的数据复制到用户态 or 将用户态的数据复制到内核态。</p><p>参数 1：页表<br>参数 2、3：目的地址和传输内容<br>参数 4：传输内容长度</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span> &#123;</span><br><span class="line">    uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        va0 = PGROUNDDOWN(dstva);</span><br><span class="line">        pa0 = walkaddr(pagetable, va0);</span><br><span class="line">        <span class="keyword">if</span> (pa0 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        n = PGSIZE - (dstva - va0);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len)</span><br><span class="line">            n = len;</span><br><span class="line">        memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">        len -= n;</span><br><span class="line">        src += n;</span><br><span class="line">        dstva = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy from user to kernel.</span></span><br><span class="line"><span class="comment">// Copy len bytes to dst from virtual address srcva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copyin</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">char</span> *dst, uint64 srcva, uint64 len)</span> &#123;</span><br><span class="line">    uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        va0 = PGROUNDDOWN(srcva);</span><br><span class="line">        pa0 = walkaddr(pagetable, va0);</span><br><span class="line">        <span class="keyword">if</span> (pa0 == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        n = PGSIZE - (srcva - va0);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; len)</span><br><span class="line">            n = len;</span><br><span class="line">        memmove(dst, (<span class="type">void</span> *)(pa0 + (srcva - va0)), n);</span><br><span class="line"></span><br><span class="line">        len -= n;</span><br><span class="line">        dst += n;</span><br><span class="line">        srcva = va0 + PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体实施-3">具体实施</h3><h4 id="Step-1：添加-PTE-A">Step 1：添加 PTE_A</h4><p>在 <code>riscv.h</code> 中添加 <code>PTE_A</code></p><p><img src="../../assets/image-20240402213039144.png" alt=""></p><h4 id="Step-2：完善内核代码">Step 2：完善内核代码</h4><ul><li>通过 <code>argint</code> 和 <code>argaddr</code> 来获取用户态使用系统调用的参数</li><li>通过 <code>walk</code> 来获取 PTE，从而查看 <code>PTE_A</code> 权限位</li><li>通过返回一个 32 位的数来表示，表示 32 个页表每个页表是否被访问过。用二进制表示，其中的每一位 1/0 表示是否被访问过。</li><li>通过 <code>copyout</code> 将返回值放到传入参数的那个地址中</li></ul><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// lab pgtbl: your code here.</span></span><br><span class="line">    uint64 va;</span><br><span class="line">    <span class="type">int</span>    page_num;</span><br><span class="line">    uint64 abits_addr;</span><br><span class="line"></span><br><span class="line">    argaddr(<span class="number">0</span>, &amp;va);</span><br><span class="line">    argint(<span class="number">1</span>, &amp;page_num);</span><br><span class="line">    argaddr(<span class="number">2</span>, &amp;abits_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page_num &lt; <span class="number">0</span> || page_num &gt; <span class="number">32</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sys_pgaccess: page_num invalid&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32       ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pte_t</span>       *pte = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; page_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(p-&gt;pagetable, va + i * PGSIZE, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">            panic(<span class="string">&quot;sys_pgaccess: walk error&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_A) &#123;</span><br><span class="line">            ret |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            *pte &amp;= (~PTE_A);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyout(p-&gt;pagetable, abits_addr, (<span class="type">char</span> *)&amp;ret, <span class="keyword">sizeof</span>(ret)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;sys_pgaccess: copyout error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="运行结果-3">运行结果</h3><p><img src="../../assets/image-20240402215248792.png" alt=""></p><h2 id="Reference">Reference</h2><p><a href="https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/">cs wiki</a></p><p><a href="https://www.bilibili.com/video/BV19k4y1C7kA/?spm_id_from=333.337.search-card.all.click&amp;vd_source=664d223fe65c6706d11206b7416f5b92">MIT6.S081课堂视频</a><br><a href="https://github.com/duguosheng/6.S081-All-in-one">6.S081-All-in-one</a><br><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081">MIT6.S081 视频记录</a><br><a href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/summary.html">BOOK-RISCV-REV1</a></p><p><a href="https://doraemonzzz.com/tags/6-S081/">doraemonzzz’s blog</a><br><a href="https://blog.miigon.net/">Miigon’s blog</a><br><a href="https://www.cnblogs.com/weijunji/tag/XV6/">星遥见</a><br><a href="https://zhuanlan.zhihu.com/p/465640330">xv6 labs 总结</a></p><p><a href="https://www.cnblogs.com/duile/p/16087757.html">MIT6.S081-Lab3 Pgtbl 2021Fall</a><br><a href="https://www.chens.life/posts/mit-xv6-lab3/">xv6-labs-2022 Lab3 page tables</a></p>]]></content>
    
    
    <summary type="html">【MIT 6.S081】 Lab3-Page Tables(2022)</summary>
    
    
    
    <category term="OS" scheme="https://devilran6.github.io/categories/OS/"/>
    
    <category term="MIT 6.S081" scheme="https://devilran6.github.io/categories/OS/MIT-6-S081/"/>
    
    
    <category term="页表" scheme="https://devilran6.github.io/tags/%E9%A1%B5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【CSAPP】 ch9-虚拟内存</title>
    <link href="https://devilran6.github.io/posts/784dd132.html"/>
    <id>https://devilran6.github.io/posts/784dd132.html</id>
    <published>2024-03-27T15:00:00.000Z</published>
    <updated>2024-03-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>ch-9 虚拟内存</h1><p>这一章将很好的展现计算机系统中==硬件与软件相结合==的特点，和虚拟内存空间只是一个字节数组！</p><p>前半部分描述虚拟内存是如何工作的，后半部分描述应用程序是如何使用和管理虚拟内存的</p><p><img src="../../assets/image-20240311135437727.png" alt=""></p><h2 id="9-0-引入">9.0 引入</h2><p>虚拟内存（Virtual Memory, VM）的引入：为了有效管理内存并且少出错，对主存进行抽象。</p><ul><li>缓存 - 虚拟内存将主存看成高速缓存，在主存中值保留活动区域</li><li>统一 - 虚拟内存为每个进程提供了==一致==的地址空间，从而简化了内存管理</li><li>隔离 - 虚拟内存保护了每个进程的地址空间不被其他进程破坏</li></ul><h2 id="9-1-物理和虚拟寻址">9.1 物理和虚拟寻址</h2><p>==物理寻址==：<br>早期的 PC、数字信号处理器、嵌入式微控制器、Cray 超级计算机系统仍然使用物理寻址。</p><p><img src="../../assets/image-20240311213435685.png" alt=""></p><p>==虚拟寻址==：<br>CPU 生成一个虚拟地址（Virtual Address，VA），之后虚拟地址通过==硬件==内存管理单元（Memory Management Unit, MMU）转换为物理地址。</p><p>其中将虚拟地址转换为物理地址的任务叫做 地址翻译（address translation)<br><img src="../../assets/image-20240311213442901.png" alt=""></p><h2 id="9-2-地址空间">9.2 地址空间</h2><p>一个地址空间的大小是由表示最大地址所需要的==位数==所描述的。<br>例如 n 位地址空间表示包含 $2^{n}$ 个地址</p><p>规范一下后面的表示<br>物理地址大小 $M = 2^{m}$， 虚拟地址大小 $N = 2^{n}$, 虚拟页大小 $P = 2^{p}$</p><p>通过引入地址空间的概念，清楚地区分了==数据对象==（字节）和它们的==属性==（地址）</p><blockquote><p>虚拟地址是一种映射关系，程序和操作系统认为数据存储在哪个地址空间都没有关系。<br>只要能通过这个虚假的地址，找到在内存/磁盘上真正的地址，就不会出现什么问题。</p></blockquote><h2 id="9-3-虚拟内存作为缓存的工具">9.3 虚拟内存作为缓存的工具</h2><p>这部分讲述了：<br>虚拟内存是如何提供了一种机制，利用 DRAM（内存）缓存更大的虚拟地址空间（磁盘）的页面</p><h3 id="虚拟页和物理页">虚拟页和物理页</h3><p><img src="../../assets/image-20240311223100697.png" alt=""></p><p>虚拟内存表示的是==磁盘==上的 N 个连续的字节大小的单元组成的数组<br>而主存，是用来缓存磁盘中的内容的</p><p><strong>缓存机制</strong>：较低层（磁盘）上的数据被分割成块，这些块再作为较低层（磁盘）和较高层（主存）之间的传输单位。</p><p>虚拟内存被分割为==虚拟页==（Virtual Page, VP）<br>物理内存被分割成==物理页==（Physical Page, PP)，也称页帧（page frame）<br>其中虚拟页和物理页的大小均为 $P = 2^{p}$ 字节</p><p>虚拟页面的集合会分为三个==不相交==的子集</p><ul><li>未分配的：在磁盘上不存在数据</li><li>缓存的：在磁盘上存在数据，且在物理内存中也已分配页</li><li>未缓存的：在磁盘上存在数据，但不在物理内存中</li></ul><p>“未缓存的”页面指的是那些已经被虚拟内存系统分配，并且有相应数据存储在磁盘上，但当前这些数据不在物理内存中的页面。</p><p>例如下图中<br>虚拟页 0、3 为未分配的<br>虚拟页 1、4、6 为缓存在物理内存中的<br>虚拟页 2、5、7 为未缓存的</p><p><img src="../../assets/image-20240311231534318.png" alt=""></p><blockquote><p>虚拟内存和物理内存要采取分块的操作，<br>一是可以将一个程序拆分成很多小块进行存储，消除外部碎片？<br>二是方便记录映射关系，只需要记录那一块对应着那一块，而不需要记录一个起始和结束位置</p></blockquote><h3 id="DRAM-和-SRAM">DRAM 和 SRAM</h3><p><img src="../../assets/image-20240311232117387.png" alt=""><br><img src="../../assets/image-20240312101041242.png" alt=""></p><p>Static Random-Access Memory – 六个晶体管组成的闭合回路<br>Dynamic Random-Access Memory – 一个电容和一个晶体管<br>SRAM 缓存：CPU 和主存之间的 L1、L2、L3 高速缓存。<br>DRAM 缓存：虚拟内存系统的缓存，它在主存中缓存虚拟页。是指虚拟内存系统利用主存（DRAM）作为缓存来存储频繁访问的磁盘数据的过程。</p><p>DRAM 比 SRAM 约慢 10 倍，磁盘比 DRAM 约慢 100 000 倍<br>==DRAM 缓存相比 SRAM 缓存不命中要更加昂贵==<br>因为 DRAM 缓存不命中要由磁盘来服务，而 SRAM 缓存中的不命中是基于 DRAM 的主存来服务的</p><p>DRAM 缓存是==全相联==的，即任何虚拟页都可以放置在任何的物理页中，不命中的==更换策略==很重要</p><blockquote><p>Q：这里最后说的“因为对磁盘的访问时间很长，DRAM 缓存总是使用写回，而不是直写”是什么意思？<br>A：大体是，写回和直写是两种 缓存更新策略<br>写回 – 缓存中数据改变的时候，变更不会立即写入硬盘，等被换出的时候再恒心磁盘。可以减少对磁盘读写的操作，提高效率<br>直写 - 缓存中数据改变的时候，立即也改变磁盘中对应的数据，确保数据的一致性</p></blockquote><h3 id="页表">页表</h3><p>页表（Page Table）：将虚拟页映射成物理页，是一个页表条目（Page Table Entry, PTE）的数组</p><p>PTE 中有效位（valid bit）表示这页放到了 DRAM 中</p><p><img src="../../assets/image-20240312110628167.png" alt=""></p><h3 id="命中？">命中？</h3><p>页命中：通过虚拟地址找到对应的 PTE 后，发现有效位为 1，则此页面在 DRAM 中</p><p>页不命中（缺页, page fault）：<br>通过虚拟地址找到对应的 PTE 后，发现有效位为 0，则此页并没有被缓存。<br>此时将触发==缺页异常==，内核选择一个牺牲页，如果牺牲页被修改过，内核会将其复制回磁盘，再将需要的页复制到内存中。<br>当异常处理程序返回时，将==重新启动导致缺页的指令==，此时在主存中缓存了想要的地址，将顺利进行。</p><blockquote><p>Q：如何选择牺牲页 也有很多决策方案？</p></blockquote><p>在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。<br>页从磁盘换入（页面调入）DRAM 和从 DRAM 换出（页面调出）磁盘。</p><h3 id="局部性拯救了世界！">局部性拯救了世界！</h3><p>虚拟内存不命中的处罚很大，正常来讲效率会很低。<br>但是由于 ==时间局部性 和 空间局部性== 的存在，实际情况相当的好。</p><p>局部性原则保证了，程序将趋向于在一个较小的页面活动集合上工作，叫工作集</p><p>一种不幸的状态 - 抖动（thrashing）：<br>当工作集的大小超出了物理内存的大小，页面将不断的在内存和磁盘之间换进换出，此时效率极低。</p><h2 id="9-4-虚拟内存作为内存管理的工具">9.4 虚拟内存作为内存管理的工具</h2><p>页表不是唯一的，os 为每个进程提供了一个独立的页表，也就是为每个进程提供了一个独立的虚拟地址空间。有趣的是，多个虚拟页面可以映射到同一个共享物理页面上</p><p><img src="../../assets/image-20240327112126356.png" alt=""></p><ul><li><strong>简化链接</strong><br>独立的地址空间允许每个进程的内存映像使用==相同的基本格式==，根本不需要管代码和数据实际存放在物理内存的位置<br>对于 64 位地址空间，代码段总是从虚拟地址 0x400000 开始</li><li><strong>简化加载</strong><br>使得更容易向内存中加载可执行文件和共享对象文件<br>加载器可以为代码和数据段分配虚拟页，之后标记为无效的（没被缓存），当真正使用的时候再调入</li><li><strong>简化共享</strong><br>虚拟内存使得不同进程之间的数据共享变得简单。<br>通过==映射机制==，让不同进程可以轻松共享相同的物理内存页</li><li><strong>简化内存分配</strong><br>malloc 分配的 k 个==连续==的虚拟内存页面，在物理内存中可以是==分散==的任意 k 个位置</li></ul><h2 id="9-5-虚拟内存作为内存保护工具">9.5 虚拟内存作为内存保护工具</h2><p>进程的读、写、执行权限应该有明确的限制。<br>在地址翻译的过程中一定会去读 PTE 来访问物理地址，我们可以直接在 PTE 上添加一些许可位来进行权限控制！</p><ul><li>SUP 位表示是否需要在内核模式下才能访问</li><li>READ 位表示可读</li><li>WRITE 位表示可写</li></ul><p><img src="../../assets/image-20240312165342044.png" alt=""></p><p>如果违反了控制权限，会将控制传递给内核中的==异常处理程序==，报告段错误（segmentation fault）</p><h2 id="9-6-地址翻译">9.6 地址翻译</h2><h3 id="基本地址翻译">基本地址翻译</h3><p><img src="../../assets/image-20240312165729777.png" alt=""></p><p><img src="../../assets/image-20240312181010736.png" alt=""></p><p>CPU 中有一个的==页表基址寄存器==（Page Table Base Register, PTBR），指向当前页表。<br>MMU 通过虚拟页号 VPN 来选择适当的页表条目 PTE， 从页表条目 PTE 中读取到对应的物理页号 PPN。<br>物理页偏移量 PPO 和虚拟页偏移量 VPO 是相同的内容。<br>将物理页号 PPN 和物理页偏移量 PPO 直接拼接得到物理地址</p><blockquote><p>如果物理地址没有缓存在内存中，这通常意味着两种情况之一：</p><ol><li><strong>地址所对应的数据已经被换出到磁盘上</strong></li><li><strong>物理地址当前未被映射或分配</strong></li></ol></blockquote><p>页面命中完全是由硬件来处理的<br>处理缺页是硬件和操作系统内核协同完成的</p><p><strong>页面命中</strong><br><img src="../../assets/image-20240312182235164.png" alt=""></p><p><strong>页面未命中</strong><br><img src="../../assets/image-20240312182247087.png" alt=""></p><p><img src="../../assets/image-20240312182253774.png" alt=""></p><h3 id="TLB">TLB</h3><p>在 MMU 中包括一个关于 PTE 的小的缓存，称为==翻译后备缓冲器==（Translation Lookaside Buffer, TLB)</p><p><img src="../../assets/image-20240312194511640.png" alt=""></p><p>我们观察一下 这个 TLB 是如何划分 PTE 的：<br>首先 根据虚拟页表和偏移量划分为 VPN 和 VPO<br>对于 VPN 部分，==因为 TLB 被分为 $T = 2^{t}$ 个组==，<br>所以 VPN 的 t 个最低位组成 TLB索引（TLBI），VPN 的剩余位组成 TLB 标记（TLBT）</p><blockquote><p>Q：TLB 分组的个数，是不是和实际电路上的连线有关？</p></blockquote><p>==当 TLB 命中时的所有地址翻译步骤都是在芯片上的 MMU 中进行的，非常快==</p><p><img src="../../assets/image-20240312195228509.png" alt=""></p><p><img src="../../assets/image-20240312195551756.png" alt=""></p><h3 id="多级页表（时间换空间！）">多级页表（时间换空间！）</h3><p>引入：如果是单独的页表，当页表中绝大部分条都是空的时候，也仍需要分配所有条目 PTE 占用的内存，这样子显得就很浪费。</p><p>为什么这样能压缩页表？<br>第一：如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在<br>第二：只将一级页表和最经常用的二级页表放到内存中，就不用把所有条目都放进来了</p><p><img src="../../assets/image-20240312200346817.png" alt=""></p><h3 id="一个地址翻译的实例">一个地址翻译的实例</h3><p>（看书！）</p><p>…</p><h2 id="9-7-案例研究">9.7 案例研究</h2><p>略</p><h2 id="9-8-内存映射">9.8 内存映射</h2><blockquote><p>Q：？</p></blockquote><h3 id="共享对象-私有对象">共享对象 &amp; 私有对象</h3><p>Copy On Write 技术</p><p>一个私有对象开始生命周期的方式基本和共享对象的一样，在物理内存中只保存私有对象的一份副本。<br>此时，虽然两个进程将一个私有对象映射到他们虚拟内存中，但共享这个对象同一个物理副本。<br>在两个进程中这部分虚拟地址都被标记成只读不可写（在对应 PTE 中实现）<br>这个区域结构被标记为==私有的写时复制==</p><p>当一个进程想要进行写操作时，会触发保护故障，发现这部分被标记了私有的写时复制。<br>就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，恢复可写权限。</p><p><img src="../../assets/image-20240327223731510.png" alt=""></p><blockquote><p>Q：私有的写时复制 是标记在 PTE 中吗？</p></blockquote><h3 id="再看-fork">再看 <code>fork</code></h3><p>fork 创建子进程的时候，内核为子进程创建各种数据结构，分配一个 PID。<br>为了给子进程创建虚拟内存，它创建了父进程的 <code>mm_struct</code>、区域结构、和页表的==原样副本==</p><p>再将两个进程的每个页面都标记成只读，每个区域结构都标记为私有的写时复制。</p><blockquote><p>Q：mm_struct 和 区域结构是什么？</p></blockquote><h3 id="再看-execve">再看 <code>execve</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;a.out&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li>删除已存在的用户区域</li><li>映射私有区域：code data bss stack …</li><li>映射共享区域：链接库</li><li>设置程序计数器：指向代码区域的入口点</li></ul><p><img src="../../assets/image-20240327224640215.png" alt=""></p><blockquote><p>Q：这里的入口是不是汇编中写的那个 <code>__start__</code> ?</p></blockquote><h3 id="使用-mmap-函数的用户级内存映射">使用 <code>mmap</code> 函数的用户级内存映射</h3><p><code>mmap</code> 提供了一种将文件或者设备内存映射到进程的地址空间的方法。</p><p>使用 <code>mmap</code>比传统的读写文件操作（如使用 <code>read</code> 或 <code>write</code>）更高效。<br>减少数据复制，传统的 <code>read</code> 或 <code>write</code> 操作需要将数据从内核空间复制到用户空间（或反向），这个过程中会发生至少一次（通常是两次）的数据复制。<br>使用 <code>mmap</code> 映射文件到进程的地址空间后，程序可以直接在用户空间访问或修改这部分内存，操作系统会自动将对应的文件内容与这块内存同步，这样就避免了额外的数据复制。</p><h2 id="9-9-动态内存分配">9.9 动态内存分配</h2><blockquote><p>#os/todo</p></blockquote><h2 id="9-10-垃圾收集">9.10 垃圾收集</h2><blockquote><p>#os/todo</p></blockquote><h2 id="9-11-C程序中常见的与内存有关的错误">9.11 C程序中常见的与内存有关的错误</h2><blockquote><p>#os/todo</p></blockquote><h2 id="Reference">Reference</h2><p><a href="https://www.bilibili.com/video/BV1RK4y1R7Kf/?p=9&amp;spm_id_from=333.337.top_right_bar_window_history.content.click&amp;vd_source=664d223fe65c6706d11206b7416f5b92">深入理解计算机系统 - CSAPP重点导读</a></p><p><a href="https://wdxtub.com/csapp/thin-csapp-7/2016/04/16/">【读薄 CSAPP】柒 虚拟内存与动态内存分配</a></p>]]></content>
    
    
    <summary type="html">【CSAPP】 ch9-虚拟内存</summary>
    
    
    
    <category term="OS" scheme="https://devilran6.github.io/categories/OS/"/>
    
    <category term="CSAPP" scheme="https://devilran6.github.io/categories/OS/CSAPP/"/>
    
    
  </entry>
  
  <entry>
    <title>【Blog】2 渴望发呆</title>
    <link href="https://devilran6.github.io/posts/f9fc9c20.html"/>
    <id>https://devilran6.github.io/posts/f9fc9c20.html</id>
    <published>2024-03-26T15:40:19.000Z</published>
    <updated>2024-03-26T15:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../assets/Pasted%20image%2020240326234341.png" alt=""></p><p><img src="../assets/Pasted%20image%2020240326234400.png" alt=""></p><p>最近不论是做什么，都发现时间过得很快很快。愈发的渴望发呆，什么也不做，什么也不想…<br>慢慢的欣赏开花的树～</p>]]></content>
    
    
    <summary type="html">【Blog】2 渴望发呆</summary>
    
    
    
    <category term="Blog" scheme="https://devilran6.github.io/categories/Blog/"/>
    
    
    <category term="风景" scheme="https://devilran6.github.io/tags/%E9%A3%8E%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>浅谈系统调用</title>
    <link href="https://devilran6.github.io/posts/54c74d09.html"/>
    <id>https://devilran6.github.io/posts/54c74d09.html</id>
    <published>2024-03-25T16:00:00.000Z</published>
    <updated>2024-03-26T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个系统调用是如何进行的？-以-write-为例">一个系统调用是如何进行的？(以 <code>write</code> 为例)</h2><h3 id="总体概览">总体概览</h3><p>在 <code>user/user.h</code> 中声明了 <code>write</code> 函数 <code>int write(int, const void *, int);</code><br>（但我们发现找不到这个函数的函数体，因为这个函数是用汇编语句进行实现的）</p><p>在 <code>user/usys.S</code> 中找到 <code>int write(int, const void *, int)</code> 函数对应的汇编语句，里面执行 <code>ecall</code>，这是一条 <code>CPU</code> 提供的指令，执行完跳转到 <code>SupervisorMode</code></p><p>从 <code>UserMode</code> 到 <code>SupervisorMode</code> 之间经历跳板（TODO）<br>跳板到 <code>kernel/syscall.c</code> 中的 <code>void syscall(void)</code></p><p>在 <code>kernel/syscall.c</code> 中调用 <code>void syscall(void)</code> 函数，跳转到 <code>syscalls</code> 这个数组中对应存着的 <code>uint64 sys_write(void)</code> 函数的地址</p><p>在 <code>kernel/sysfile.c</code> 中有这 <code>uint64 sys_write(void)</code> 的函数体，执行 <code>write</code> 操作</p><p>之后再一步步的返回</p><p><img src="../assets/image-20240321231828744.png" alt=""></p><h3 id="分步骤看">分步骤看</h3><h4 id="step-1-从系统调用-write-入手">step 1: 从系统调用 <code>write</code> 入手</h4><p>在 <code>user/user.h</code> 中声明了 <code>write</code> 函数 <code>int write(int, const void *, int);</code><br>（但我们发现找不到这个函数的函数体，因为这个函数是用汇编语句进行实现的）</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>我们在正常代码中用的，c语言中的 <code>write</code><br>实际上是系统调用的一个包装，它的函数声明位于 <code>user/user.h</code>，只有一个声明，实际的函数体是由汇编指令洗的，位于 <code>user/usys.S</code></p><p>by the way: 如何生成的对应的汇编代码<br><code>user/usys.pl</code> 在 make 后会生成 <code>user/usys.S</code> 文件<br>其中 <code>usys.pl</code> 文件就是一个用于生成对应汇编文件的<strong>脚本文件</strong>，里面一个 <code>entry</code> 函数，<br>调用 <code>entry(&quot;write&quot;)</code>，生成 <code>write</code> 函数对应的汇编代码</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="step-2：write-的汇编调用-ecall">step 2：<code>write</code> 的汇编调用 <code>ecall</code></h4><p>在 <code>user/usys.S</code> 中找到 <code>int write(int, const void *, int)</code> 函数对应的汇编语句，里面执行 <code>ecall</code>，这是一条 <code>CPU</code> 提供的指令，执行完跳转到 <code>kernel mode</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.S</span></span><br><span class="line"></span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>我们来具体的看一看汇编代码，它由三条汇编指令构成<br>第一条是将 <code>SYS_write</code> 放到 <code>a7</code> 中，这是一个声明在 <code>syscall.h</code> 中的宏，值为 16.<br>每个 <code>syscall</code> 都有一个对应的宏，叫 <code>System call numbers</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br></pre></td></tr></table></figure><p>第二条是执行 <code>ecall</code></p><p>第三条是 返回</p><h4 id="step-3：从-ecall-到-trampoline">step 3：从 <code>ecall</code> 到 <code>trampoline</code></h4><p>从 user mode 到 kernel mode 之间经历跳板（TODO）<br>跳板到 <code>kernel/syscall.c</code> 中的 <code>void syscall(void)</code></p><p>ecall 将会做三件事</p><ul><li>将 <code>pc</code> 存储到 <code>sepc</code></li><li>从 <code>user mode</code> 提升到 <code>supervisor mode</code></li><li>跳转到 <code>STVEC</code></li></ul><blockquote><p>#os/todo 用 gdb 调试，显示一步步的变化</p></blockquote><blockquote><p>#os/q <code>kernelvec.S</code>  这里面的代码是干什么的？ 怎么有说法是说 <code>STVEC</code> 跳转到这里</p></blockquote><p>现在 <code>pc</code> 指向 <code>STVEC</code> 中的地址，<code>STVEC</code> 寄存器指向的是 <code>0x3ffffff000</code>。<br>这个地址在 用户虚拟地址空间和虚拟地址空间中 都是最顶部的部分，即 <code>trampoline</code></p><p><code>trampoline</code> 是蹦床的意思，指的是 从 <code>user mode</code> 跳转到 <code>supervisor mode</code><br>这部分代码是模式转换的关键</p><p><strong>trampline 在 usermode 和 supervisormode 之中的虚拟地址映射是相同的</strong><br>这样的好处是，在模式转换的过程中，我们从 user 的页表切换到 kernel 的页表的过程中，程序不会崩溃。<br>因为在 pc 中需要继续运行的虚拟地址是一样的</p><p><img src="../assets/image-20240322101340784.png" alt=""></p><h4 id="step-4：-trampoline-从保存用户数据到-void-usertrap-void">step 4： <code>trampoline</code>-从保存用户数据到 <code>void usertrap(void)</code></h4><p>Q：等下你可能会好奇？内核中的这些寄存器中的数都是什么时候设置的？<br>ans：从最初启动，到每次中断恢复，都会对内核数据进行设置的</p><p>现在我们已经到了 <code>kernel/trampoline.S</code> 中的 <code>trampoline</code>，我们已经是 <code>SupervisorMode</code> 了。<br>但我们现在并不能直接执行 内核代码，因为执行代码需要使用 寄存器。<br>但现在寄存器存储着 <code>UserMode</code> 中暂停时的数据，等执行完内核代码还要进行恢复。</p><p>所以我们首先需要保存 <code>UserMode</code> 的寄存器，所有寄存器的数值将保存到 <code>trapframe</code> 中。<br>而 有一个叫 <code>sscratch</code> 的寄存器存储着 <code>trapframe</code> 的地址</p><p><code>trapframe</code> 是一个存储所有用户寄存器的结构，在地址空间中位于 <code>trampoline</code> 的下方。<br>值得注意的是：目前执行到这里时，所用的页表还是 <code>UserMode</code> 的页表，还没有进行切换。所以 <code>trapframe</code> 在 <code>UserMode</code> 和 <code>SupervisorMode</code> 中的虚拟地址也是相同的，其通过 <code>UserMode</code> 的页表也可以访问</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">    <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">    <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">    <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">    <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">    <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">    <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">    <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">    <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">    <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">    <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">    <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">    <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">    <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">    <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">    <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">    <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">    <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">    <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">    <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">    <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">    <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">    <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">    <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">    <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">    <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">    <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">    <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">    <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">    <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">    <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">    <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">    <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">    <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">    <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">    <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="保存用户寄存器">保存用户寄存器</h5><p>首先将调换 <code>sscratch</code> 和 <code>a0</code> 寄存器，此时 <code>a0</code> 寄存器中为 <code>trapframe</code> 的地址，后面即可将所有的用户寄存器都存到 <code>trapframe</code> 中<br>（这样子做的原因是 <code>sd</code> 指令需要用户寄存器执行）</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">trampoline:</span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line"></span><br><span class="line">        <span class="meta"># save user a0 in sscratch so</span></span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">        <span class="meta"># each process has a separate p-&gt;trapframe memory area,</span></span><br><span class="line">        <span class="meta"># but it<span class="string">&#x27;s mapped to the same virtual address</span></span></span><br><span class="line"><span class="string"><span class="meta">        # (TRAPFRAME) in every process&#x27;</span>s user page table.</span></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># save the user registers in TRAPFRAME</span></span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd sp, <span class="number">48</span>(a0)</span><br><span class="line">        sd gp, <span class="number">56</span>(a0)</span><br><span class="line">        sd tp, <span class="number">64</span>(a0)</span><br><span class="line">        sd t0, <span class="number">72</span>(a0)</span><br><span class="line">        sd t1, <span class="number">80</span>(a0)</span><br><span class="line">        sd t2, <span class="number">88</span>(a0)</span><br><span class="line">        sd s0, <span class="number">96</span>(a0)</span><br><span class="line">        sd s1, <span class="number">104</span>(a0)</span><br><span class="line">        sd a1, <span class="number">120</span>(a0)</span><br><span class="line">        sd a2, <span class="number">128</span>(a0)</span><br><span class="line">        sd a3, <span class="number">136</span>(a0)</span><br><span class="line">        sd a4, <span class="number">144</span>(a0)</span><br><span class="line">        sd a5, <span class="number">152</span>(a0)</span><br><span class="line">        sd a6, <span class="number">160</span>(a0)</span><br><span class="line">        sd a7, <span class="number">168</span>(a0)</span><br><span class="line">        sd s2, <span class="number">176</span>(a0)</span><br><span class="line">        sd s3, <span class="number">184</span>(a0)</span><br><span class="line">        sd s4, <span class="number">192</span>(a0)</span><br><span class="line">        sd s5, <span class="number">200</span>(a0)</span><br><span class="line">        sd s6, <span class="number">208</span>(a0)</span><br><span class="line">        sd s7, <span class="number">216</span>(a0)</span><br><span class="line">        sd s8, <span class="number">224</span>(a0)</span><br><span class="line">        sd s9, <span class="number">232</span>(a0)</span><br><span class="line">        sd s10, <span class="number">240</span>(a0)</span><br><span class="line">        sd s11, <span class="number">248</span>(a0)</span><br><span class="line">        sd t3, <span class="number">256</span>(a0)</span><br><span class="line">        sd t4, <span class="number">264</span>(a0)</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="再将-初始用户中的-a0-存到-trapframe-中">再将 初始用户中的 <code>a0</code> 存到 <code>trapframe</code> 中</h5><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trapoline.S</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    csrr t0, sscratch</span><br><span class="line">    sd t0, <span class="number">112</span>(a0)</span><br></pre></td></tr></table></figure><h5 id="切换内核环境">切换内核环境</h5><p>现在已经将所有的 用户数据都保存完了，下一步是将 <code>tramframe</code> 中关于内核的数据如 内核页表，内核栈指针… 加载出来，</p><ul><li>加载栈指针到 <code>sp</code></li><li>加载当前处理器的硬件线程ID（HART ID，Hardware Thread ID）到 <code>tp</code></li><li>将 <code>usertrap</code> 函数的地址放到 t<code>0</code></li><li>加载内核页表到 <code>satp</code></li><li>清空 <code>TLB</code>！！！</li><li>跳转到 <code>t0</code> 即 <code>usertrap()</code> 函数</li></ul><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">        <span class="meta"># initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line"># 栈指针</span><br><span class="line">        ld sp, <span class="number">8</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line"># 将 usertrap() 的地址放到 t0</span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta"># fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span></span><br><span class="line">        # 加载内核页表</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># wait for any previous memory operations to complete, so that</span></span><br><span class="line">        <span class="meta"># they use the user page table.</span></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># install the kernel page table.</span></span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        <span class="meta"># flush now-stale user entries from the TLB.</span></span><br><span class="line">        # 清空 TLB</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># jump to usertrap(), which does not return</span></span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><h4 id="step-5：执行-usertrap">step 5：执行 <code>usertrap()</code></h4><blockquote><p>#os/todo 这部分等以后再详细补充</p></blockquote><p>我们主要知道在这里会调用 <code>syscall()</code><br>并在最后会调用 <code>usertrapret()</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">    <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">    w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save user program counter.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_scause() == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (killed(p))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">        <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">        p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">        <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">        intr_on();</span><br><span class="line"></span><br><span class="line">        syscall();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ok</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        setkilled(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (killed(p))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">    <span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">        yield();</span><br><span class="line"></span><br><span class="line">    usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step-6：执行-syscall">step 6：执行 <code>syscall()</code></h4><p>在 <code>write</code> 的汇编代码中，将参数 <code>SYS_write</code> 存放到了 <code>a7</code> 寄存器中，后保存到了 <code>trapframe</code><br>在 <code>syscall.c</code> 中，从 <code>p-&gt;trapframe-&gt;a7</code> 即可取出参数，这标志的将要执行哪个系统调用</p><p>之后从 <code>syscalls[num]</code> 找到对应内核代码的地址，并执行；如果没有找到对应的系统调用将会把返回值 <code>-1</code> 放到 <code>p-&gt;trapframe-a0</code> 中</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">        <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (new)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;syscall_trace &amp; (<span class="number">1</span> &lt;&lt; num)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">               p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step-7：回到-usertrapret-执行-usertrapret">step 7：回到 <code>usertrapret()</code> 执行 <code>usertrapret()</code></h4><blockquote><p>#os/todo</p></blockquote><p>此时系统调用已经执行完毕，将要进行恢复用户数据的操作<br>在 <code>usertrapret()</code> 的最后会执行 <code>trampoline.S</code> 中的 <code>userret</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">    <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">    <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">    intr_off();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">    uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">    w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">    <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">    p-&gt;trapframe-&gt;kernel_hartid = r_tp(); <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">    <span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">    x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">    x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">    w_sstatus(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">    w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">    uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jump to userret in trampoline.S at the top of memory, which</span></span><br><span class="line">    <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">    <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">    uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">    ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="step-8-执行-trampoline-S-中的-userret">step 8: 执行 <code>trampoline.S</code> 中的 <code>userret</code></h4><blockquote><p>#os/todo</p></blockquote><p>恢复所有的寄存器，pc…</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        <span class="meta"># userret(pagetable)</span></span><br><span class="line">        <span class="meta"># called by usertrapret() in trap.c to</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        # a0: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"></span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld s0, <span class="number">96</span>(a0)</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        ld a2, <span class="number">128</span>(a0)</span><br><span class="line">        ld a3, <span class="number">136</span>(a0)</span><br><span class="line">        ld a4, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld s2, <span class="number">176</span>(a0)</span><br><span class="line">        ld s3, <span class="number">184</span>(a0)</span><br><span class="line">        ld s4, <span class="number">192</span>(a0)</span><br><span class="line">        ld s5, <span class="number">200</span>(a0)</span><br><span class="line">        ld s6, <span class="number">208</span>(a0)</span><br><span class="line">        ld s7, <span class="number">216</span>(a0)</span><br><span class="line">        ld s8, <span class="number">224</span>(a0)</span><br><span class="line">        ld s9, <span class="number">232</span>(a0)</span><br><span class="line">        ld s10, <span class="number">240</span>(a0)</span><br><span class="line">        ld s11, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># restore user a0</span></span><br><span class="line">        ld a0, <span class="number">112</span>(a0)</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><h2 id="如何创建一个新的系统调用？">如何创建一个新的系统调用？</h2><blockquote><p>#os/todo</p></blockquote><h3 id="step-1：">step 1：</h3><p>在如 <code>kernel/sysproc.c</code> <code>kernel/sysfile.c</code> 等等中添加真正要在内核中执行的代码</p><p>例如 在 <code>kernel/sysfile.c</code> 中有 <code>write</code> 的内核代码</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    uint64 p;</span><br><span class="line"></span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">    argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step-2：">step 2：</h3><p>在 <code>kernel/syscall.h</code> 中声明对应系统调用的宏</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace 22 <span class="comment">// (new)</span></span></span><br></pre></td></tr></table></figure><h3 id="step-3：">step 3：</h3><p>在 <code>kernel/syscall.c</code> 中全局声明系统调用函数，并将其添加进 <code>syscalls</code> 映射表。<br>这样子在执行 <code>syscall()</code> 函数的时候能通过 <code>syscalls</code> 找到系统调用函数的地址</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototypes for the functions that handle system calls.</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// (new)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork] sys_fork,</span><br><span class="line">    [SYS_exit] sys_exit,</span><br><span class="line">    [SYS_wait] sys_wait,</span><br><span class="line">    [SYS_pipe] sys_pipe,</span><br><span class="line">    [SYS_read] sys_read,</span><br><span class="line">    [SYS_kill] sys_kill,</span><br><span class="line">    [SYS_exec] sys_exec,</span><br><span class="line">    [SYS_fstat] sys_fstat,</span><br><span class="line">    [SYS_chdir] sys_chdir,</span><br><span class="line">    [SYS_dup] sys_dup,</span><br><span class="line">    [SYS_getpid] sys_getpid,</span><br><span class="line">    [SYS_sbrk] sys_sbrk,</span><br><span class="line">    [SYS_sleep] sys_sleep,</span><br><span class="line">    [SYS_uptime] sys_uptime,</span><br><span class="line">    [SYS_open] sys_open,</span><br><span class="line">    [SYS_write] sys_write,</span><br><span class="line">    [SYS_mknod] sys_mknod,</span><br><span class="line">    [SYS_unlink] sys_unlink,</span><br><span class="line">    [SYS_link] sys_link,</span><br><span class="line">    [SYS_mkdir] sys_mkdir,</span><br><span class="line">    [SYS_close] sys_close,</span><br><span class="line">    [SYS_trace] sys_trace, <span class="comment">// (new)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>step 4：<br>在 <code>user/usys.pl</code> 中对新的系统调用使用 <code>entry()</code>，使得在生成的 <code>user/usys.S</code> 中有系统调用的汇编代码</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.S</span></span><br><span class="line"></span><br><span class="line">write:</span><br><span class="line">li a7, SYS_write</span><br><span class="line">ecall</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>step 5：</p><p>最后在 user/user.h 中添加系统调用函数的声明</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// (new)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">浅谈系统调用</summary>
    
    
    
    <category term="OS" scheme="https://devilran6.github.io/categories/OS/"/>
    
    
    <category term="系统调用" scheme="https://devilran6.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【Blog】 1 春天要来了！</title>
    <link href="https://devilran6.github.io/posts/d1e1a83e.html"/>
    <id>https://devilran6.github.io/posts/d1e1a83e.html</id>
    <published>2024-03-23T11:00:00.000Z</published>
    <updated>2024-03-23T14:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天去逛了逛公园，见到了没开花的海棠和盛开的水桃花，以及一个哈哈哈抬头撞到的鸟窝！</p><p><img src="../assets/image-20240323190041513.png" alt=""></p><p><img src="../assets/image-20240323190526694.png" alt=""></p><p><img src="../assets/image-20240323190549081.png" alt=""></p><p>以及最近看到小土刀的一段话<br>“这种负重前行的生活，更加让我意识到盼头的重要性，生活需要希望，工作更需要远大的目标。但使命感如何建立，并不容易，需要一点一滴构建和小心呵护。”</p><p><img src="../assets/2024-03-23-19-18-19.png" alt=""></p>]]></content>
    
    
    <summary type="html">【Blog】 1 春天要来了！</summary>
    
    
    
    <category term="Blog" scheme="https://devilran6.github.io/categories/Blog/"/>
    
    
    <category term="风景" scheme="https://devilran6.github.io/tags/%E9%A3%8E%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.S081】 Lab2-System calls</title>
    <link href="https://devilran6.github.io/posts/81fc3da1.html"/>
    <id>https://devilran6.github.io/posts/81fc3da1.html</id>
    <published>2024-03-22T16:00:00.000Z</published>
    <updated>2024-03-23T13:43:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a><br>Lab 地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a><br>我的代码地址：<a href="https://github.com/devilran6/devilran-xv6/tree/syscall">https://github.com/devilran6/devilran-xv6/tree/syscall</a><br>Commits：<a href="https://github.com/devilran6/devilran-xv6/commits/syscall/">https://github.com/devilran6/devilran-xv6/commits/syscall/</a></p></blockquote><h1>Lab2-System calls</h1><blockquote><p>In the last lab you used systems calls to write a few utilities. In this lab you will add some new system calls to xv6, which will help you understand how they work and will expose you to some of the internals of the xv6 kernel. You will add more system calls in later labs.</p></blockquote><p>给 xv6 添加一些 system calls</p><h2 id="一个系统调用是如何进行的？-以-write-为例">一个系统调用是如何进行的？(以 <code>write</code> 为例)</h2><blockquote><p>#os/todo</p></blockquote><h3 id="总体概览">总体概览</h3><p>在 <code>user/user.h</code> 中声明了 <code>write</code> 函数 <code>int write(int, const void *, int);</code><br>（但我们发现找不到这个函数的函数体，因为这个函数是用汇编语句进行实现的）</p><p>在 <code>user/usys.S</code> 中找到 <code>int write(int, const void *, int)</code> 函数对应的汇编语句，里面执行 <code>ecall</code>，这是一条 <code>CPU</code> 提供的指令，执行完跳转到 <code>SupervisorMode</code></p><p>从 <code>UserMode</code> 到 <code>SupervisorMode</code> 之间经历跳板（TODO）<br>跳板到 <code>kernel/syscall.c</code> 中的 <code>void syscall(void)</code></p><p>在 <code>kernel/syscall.c</code> 中调用 <code>void syscall(void)</code> 函数，跳转到 <code>syscalls</code> 这个数组中对应存着的 <code>uint64 sys_write(void)</code> 函数的地址</p><p>在 <code>kernel/sysfile.c</code> 中有这 <code>uint64 sys_write(void)</code> 的函数体，执行 <code>write</code> 操作</p><p>之后再一步步的返回</p><p><img src="../assets/image-20240321231828744.png" alt=""></p><h3 id="分步骤看">分步骤看</h3><h4 id="step-1-从系统调用-write-入手">step 1: 从系统调用 <code>write</code> 入手</h4><p>在 <code>user/user.h</code> 中声明了 <code>write</code> 函数 <code>int write(int, const void *, int);</code><br>（但我们发现找不到这个函数的函数体，因为这个函数是用汇编语句进行实现的）</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure><p>我们在正常代码中用的，c语言中的 <code>write</code><br>实际上是系统调用的一个包装，它的函数声明位于 <code>user/user.h</code>，只有一个声明，实际的函数体是由汇编指令洗的，位于 <code>user/usys.S</code></p><p>by the way: 如何生成的对应的汇编代码<br><code>user/usys.pl</code> 在 make 后会生成 <code>user/usys.S</code> 文件<br>其中 <code>usys.pl</code> 文件就是一个用于生成对应汇编文件的<strong>脚本文件</strong>，里面一个 <code>entry</code> 函数，<br>调用 <code>entry(&quot;write&quot;)</code>，生成 <code>write</code> 函数对应的汇编代码</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line"></span><br><span class="line">sub entry &#123;</span><br><span class="line">    my $name = shift;</span><br><span class="line">    print <span class="string">&quot;.global $name\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot;$&#123;name&#125;:\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; li a7, SYS_$&#123;name&#125;\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ecall\n&quot;</span>;</span><br><span class="line">    print <span class="string">&quot; ret\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="step-2：write-的汇编调用-ecall">step 2：<code>write</code> 的汇编调用 <code>ecall</code></h4><p>在 <code>user/usys.S</code> 中找到 <code>int write(int, const void *, int)</code> 函数对应的汇编语句，里面执行 <code>ecall</code>，这是一条 <code>CPU</code> 提供的指令，执行完跳转到 <code>kernel mode</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.S</span></span><br><span class="line"></span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><p>我们来具体的看一看汇编代码，它由三条汇编指令构成<br>第一条是将 <code>SYS_write</code> 放到 <code>a7</code> 中，这是一个声明在 <code>syscall.h</code> 中的宏，值为 16.<br>每个 <code>syscall</code> 都有一个对应的宏，叫 <code>System call numbers</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br></pre></td></tr></table></figure><p>第二条是执行 <code>ecall</code></p><p>第三条是 返回</p><h4 id="step-3：从-ecall-到-trampoline">step 3：从 <code>ecall</code> 到 <code>trampoline</code></h4><p>从 user mode 到 kernel mode 之间经历跳板（TODO）<br>跳板到 <code>kernel/syscall.c</code> 中的 <code>void syscall(void)</code></p><p>ecall 将会做三件事</p><ul><li>将 <code>pc</code> 存储到 <code>sepc</code></li><li>从 <code>user mode</code> 提升到 <code>supervisor mode</code></li><li>跳转到 <code>STVEC</code></li></ul><blockquote><p>#os/todo 用 gdb 调试，显示一步步的变化</p></blockquote><blockquote><p>#os/q <code>kernelvec.S</code>  这里面的代码是干什么的？ 怎么有说法是说 <code>STVEC</code> 跳转到这里</p></blockquote><p>现在 <code>pc</code> 指向 <code>STVEC</code> 中的地址，<code>STVEC</code> 寄存器指向的是 <code>0x3ffffff000</code>。<br>这个地址在 用户虚拟地址空间和虚拟地址空间中 都是最顶部的部分，即 <code>trampoline</code></p><p><code>trampoline</code> 是蹦床的意思，指的是 从 <code>user mode</code> 跳转到 <code>supervisor mode</code><br>这部分代码是模式转换的关键</p><p><strong>trampline 在 usermode 和 supervisormode 之中的虚拟地址映射是相同的</strong><br>这样的好处是，在模式转换的过程中，我们从 user 的页表切换到 kernel 的页表的过程中，程序不会崩溃。<br>因为在 pc 中需要继续运行的虚拟地址是一样的</p><p><img src="../assets/image-20240322101340784.png" alt=""></p><h4 id="step-4：-trampoline-从保存用户数据到-void-usertrap-void">step 4： <code>trampoline</code>-从保存用户数据到 <code>void usertrap(void)</code></h4><p>Q：等下你可能会好奇？内核中的这些寄存器中的数都是什么时候设置的？<br>ans：从最初启动，到每次中断恢复，都会对内核数据进行设置的</p><p>现在我们已经到了 <code>kernel/trampoline.S</code> 中的 <code>trampoline</code>，我们已经是 <code>SupervisorMode</code> 了。<br>但我们现在并不能直接执行 内核代码，因为执行代码需要使用 寄存器。<br>但现在寄存器存储着 <code>UserMode</code> 中暂停时的数据，等执行完内核代码还要进行恢复。</p><p>所以我们首先需要保存 <code>UserMode</code> 的寄存器，所有寄存器的数值将保存到 <code>trapframe</code> 中。<br>而 有一个叫 <code>sscratch</code> 的寄存器存储着 <code>trapframe</code> 的地址</p><p><code>trapframe</code> 是一个存储所有用户寄存器的结构，在地址空间中位于 <code>trampoline</code> 的下方。<br>值得注意的是：目前执行到这里时，所用的页表还是 <code>UserMode</code> 的页表，还没有进行切换。所以 <code>trapframe</code> 在 <code>UserMode</code> 和 <code>SupervisorMode</code> 中的虚拟地址也是相同的，其通过 <code>UserMode</code> 的页表也可以访问</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// per-process data for the trap handling code in trampoline.S.</span></span><br><span class="line"><span class="comment">// sits in a page by itself just under the trampoline page in the</span></span><br><span class="line"><span class="comment">// user page table. not specially mapped in the kernel page table.</span></span><br><span class="line"><span class="comment">// uservec in trampoline.S saves user registers in the trapframe,</span></span><br><span class="line"><span class="comment">// then initializes registers from the trapframe&#x27;s</span></span><br><span class="line"><span class="comment">// kernel_sp, kernel_hartid, kernel_satp, and jumps to kernel_trap.</span></span><br><span class="line"><span class="comment">// usertrapret() and userret in trampoline.S set up</span></span><br><span class="line"><span class="comment">// the trapframe&#x27;s kernel_*, restore user registers from the</span></span><br><span class="line"><span class="comment">// trapframe, switch to the user page table, and enter user space.</span></span><br><span class="line"><span class="comment">// the trapframe includes callee-saved user registers like s0-s11 because the</span></span><br><span class="line"><span class="comment">// return-to-user path via usertrapret() doesn&#x27;t return through</span></span><br><span class="line"><span class="comment">// the entire kernel call stack.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">    <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">    <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">    <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">    <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">    <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">    <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">    <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">    <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">    <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">    <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">    <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">    <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">    <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">    <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">    <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">    <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">    <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">    <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">    <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">    <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">    <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">    <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">    <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">    <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">    <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">    <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">    <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">    <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">    <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">    <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">    <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">    <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">    <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">    <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">    <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="保存用户寄存器">保存用户寄存器</h5><p>首先将调换 <code>sscratch</code> 和 <code>a0</code> 寄存器，此时 <code>a0</code> 寄存器中为 <code>trapframe</code> 的地址，后面即可将所有的用户寄存器都存到 <code>trapframe</code> 中<br>（这样子做的原因是 <code>sd</code> 指令需要用户寄存器执行）</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">trampoline:</span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">.globl uservec</span><br><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line"></span><br><span class="line">        <span class="meta"># save user a0 in sscratch so</span></span><br><span class="line">        # a0 can be used to get at TRAPFRAME.</span><br><span class="line">        csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">        <span class="meta"># each process has a separate p-&gt;trapframe memory area,</span></span><br><span class="line">        <span class="meta"># but it<span class="string">&#x27;s mapped to the same virtual address</span></span></span><br><span class="line"><span class="string"><span class="meta">        # (TRAPFRAME) in every process&#x27;</span>s user page table.</span></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># save the user registers in TRAPFRAME</span></span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd sp, <span class="number">48</span>(a0)</span><br><span class="line">        sd gp, <span class="number">56</span>(a0)</span><br><span class="line">        sd tp, <span class="number">64</span>(a0)</span><br><span class="line">        sd t0, <span class="number">72</span>(a0)</span><br><span class="line">        sd t1, <span class="number">80</span>(a0)</span><br><span class="line">        sd t2, <span class="number">88</span>(a0)</span><br><span class="line">        sd s0, <span class="number">96</span>(a0)</span><br><span class="line">        sd s1, <span class="number">104</span>(a0)</span><br><span class="line">        sd a1, <span class="number">120</span>(a0)</span><br><span class="line">        sd a2, <span class="number">128</span>(a0)</span><br><span class="line">        sd a3, <span class="number">136</span>(a0)</span><br><span class="line">        sd a4, <span class="number">144</span>(a0)</span><br><span class="line">        sd a5, <span class="number">152</span>(a0)</span><br><span class="line">        sd a6, <span class="number">160</span>(a0)</span><br><span class="line">        sd a7, <span class="number">168</span>(a0)</span><br><span class="line">        sd s2, <span class="number">176</span>(a0)</span><br><span class="line">        sd s3, <span class="number">184</span>(a0)</span><br><span class="line">        sd s4, <span class="number">192</span>(a0)</span><br><span class="line">        sd s5, <span class="number">200</span>(a0)</span><br><span class="line">        sd s6, <span class="number">208</span>(a0)</span><br><span class="line">        sd s7, <span class="number">216</span>(a0)</span><br><span class="line">        sd s8, <span class="number">224</span>(a0)</span><br><span class="line">        sd s9, <span class="number">232</span>(a0)</span><br><span class="line">        sd s10, <span class="number">240</span>(a0)</span><br><span class="line">        sd s11, <span class="number">248</span>(a0)</span><br><span class="line">        sd t3, <span class="number">256</span>(a0)</span><br><span class="line">        sd t4, <span class="number">264</span>(a0)</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="再将-初始用户中的-a0-存到-trapframe-中">再将 初始用户中的 <code>a0</code> 存到 <code>trapframe</code> 中</h5><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trapoline.S</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    csrr t0, sscratch</span><br><span class="line">    sd t0, <span class="number">112</span>(a0)</span><br></pre></td></tr></table></figure><h5 id="切换内核环境">切换内核环境</h5><p>现在已经将所有的 用户数据都保存完了，下一步是将 <code>tramframe</code> 中关于内核的数据如 内核页表，内核栈指针… 加载出来，</p><ul><li>加载栈指针到 <code>sp</code></li><li>加载当前处理器的硬件线程ID（HART ID，Hardware Thread ID）到 <code>tp</code></li><li>将 <code>usertrap</code> 函数的地址放到 t<code>0</code></li><li>加载内核页表到 <code>satp</code></li><li>清空 <code>TLB</code>！！！</li><li>跳转到 <code>t0</code> 即 <code>usertrap()</code> 函数</li></ul><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">        <span class="meta"># initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line"># 栈指针</span><br><span class="line">        ld sp, <span class="number">8</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line"># 将 usertrap() 的地址放到 t0</span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta"># fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span></span><br><span class="line">        # 加载内核页表</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># wait for any previous memory operations to complete, so that</span></span><br><span class="line">        <span class="meta"># they use the user page table.</span></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># install the kernel page table.</span></span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        <span class="meta"># flush now-stale user entries from the TLB.</span></span><br><span class="line">        # 清空 TLB</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># jump to usertrap(), which does not return</span></span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><h4 id="step-5：执行-usertrap">step 5：执行 <code>usertrap()</code></h4><blockquote><p>#os/todo 这部分等以后再详细补充</p></blockquote><p>我们主要知道在这里会调用 <code>syscall()</code><br>并在最后会调用 <code>usertrapret()</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">    <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">    w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save user program counter.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r_scause() == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (killed(p))</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">        <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">        p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">        <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">        intr_on();</span><br><span class="line"></span><br><span class="line">        syscall();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((which_dev = devintr()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// ok</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">        setkilled(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (killed(p))</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">    <span class="keyword">if</span> (which_dev == <span class="number">2</span>)</span><br><span class="line">        yield();</span><br><span class="line"></span><br><span class="line">    usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step-6：执行-syscall">step 6：执行 <code>syscall()</code></h4><p>在 <code>write</code> 的汇编代码中，将参数 <code>SYS_write</code> 存放到了 <code>a7</code> 寄存器中，后保存到了 <code>trapframe</code><br>在 <code>syscall.c</code> 中，从 <code>p-&gt;trapframe-&gt;a7</code> 即可取出参数，这标志的将要执行哪个系统调用</p><p>之后从 <code>syscalls[num]</code> 找到对应内核代码的地址，并执行；如果没有找到对应的系统调用将会把返回值 <code>-1</code> 放到 <code>p-&gt;trapframe-a0</code> 中</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">        <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (new)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;syscall_trace &amp; (<span class="number">1</span> &lt;&lt; num)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">               p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step-7：回到-usertrapret-执行-usertrapret">step 7：回到 <code>usertrapret()</code> 执行 <code>usertrapret()</code></h4><blockquote><p>#os/todo</p></blockquote><p>此时系统调用已经执行完毕，将要进行恢复用户数据的操作<br>在 <code>usertrapret()</code> 的最后会执行 <code>trampoline.S</code> 中的 <code>userret</code></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trap.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">    <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">    <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">    intr_off();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">    uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">    w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">    <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">    p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">    p-&gt;trapframe-&gt;kernel_hartid = r_tp(); <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">    <span class="comment">// to get to user space.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">    x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">    x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">    w_sstatus(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">    w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">    uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jump to userret in trampoline.S at the top of memory, which</span></span><br><span class="line">    <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">    <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">    uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">    ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="step-8-执行-trampoline-S-中的-userret">step 8: 执行 <code>trampoline.S</code> 中的 <code>userret</code></h4><blockquote><p>#os/todo</p></blockquote><p>恢复所有的寄存器，pc…</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/trampoline.S</span></span><br><span class="line"></span><br><span class="line">.globl userret</span><br><span class="line">userret:</span><br><span class="line">        <span class="meta"># userret(pagetable)</span></span><br><span class="line">        <span class="meta"># called by usertrapret() in trap.c to</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        # a0: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"></span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line">        csrw satp, a0</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld s0, <span class="number">96</span>(a0)</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        ld a2, <span class="number">128</span>(a0)</span><br><span class="line">        ld a3, <span class="number">136</span>(a0)</span><br><span class="line">        ld a4, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld s2, <span class="number">176</span>(a0)</span><br><span class="line">        ld s3, <span class="number">184</span>(a0)</span><br><span class="line">        ld s4, <span class="number">192</span>(a0)</span><br><span class="line">        ld s5, <span class="number">200</span>(a0)</span><br><span class="line">        ld s6, <span class="number">208</span>(a0)</span><br><span class="line">        ld s7, <span class="number">216</span>(a0)</span><br><span class="line">        ld s8, <span class="number">224</span>(a0)</span><br><span class="line">        ld s9, <span class="number">232</span>(a0)</span><br><span class="line">        ld s10, <span class="number">240</span>(a0)</span><br><span class="line">        ld s11, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># restore user a0</span></span><br><span class="line">        ld a0, <span class="number">112</span>(a0)</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><h2 id="如何创建一个新的系统调用？">如何创建一个新的系统调用？</h2><blockquote><p>#os/todo</p></blockquote><h3 id="step-1：">step 1：</h3><p>在如 <code>kernel/sysproc.c</code> <code>kernel/sysfile.c</code> 等等中添加真正要在内核中执行的代码</p><p>例如 在 <code>kernel/sysfile.c</code> 中有 <code>write</code> 的内核代码</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysfile.c</span></span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    uint64 p;</span><br><span class="line"></span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;p);</span><br><span class="line">    argint(<span class="number">2</span>, &amp;n);</span><br><span class="line">    <span class="keyword">if</span> (argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> filewrite(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step-2：">step 2：</h3><p>在 <code>kernel/syscall.h</code> 中声明对应系统调用的宏</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace 22 <span class="comment">// (new)</span></span></span><br></pre></td></tr></table></figure><h3 id="step-3：">step 3：</h3><p>在 <code>kernel/syscall.c</code> 中全局声明系统调用函数，并将其添加进 <code>syscalls</code> 映射表。<br>这样子在执行 <code>syscall()</code> 函数的时候能通过 <code>syscalls</code> 找到系统调用函数的地址</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prototypes for the functions that handle system calls.</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_wait</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_pipe</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_kill</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exec</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fstat</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_chdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_dup</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_sleep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_open</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_write</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mknod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_unlink</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_link</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// (new)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// An array mapping syscall numbers from syscall.h</span></span><br><span class="line"><span class="comment">// to the function that handles the system call.</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">    [SYS_fork] sys_fork,</span><br><span class="line">    [SYS_exit] sys_exit,</span><br><span class="line">    [SYS_wait] sys_wait,</span><br><span class="line">    [SYS_pipe] sys_pipe,</span><br><span class="line">    [SYS_read] sys_read,</span><br><span class="line">    [SYS_kill] sys_kill,</span><br><span class="line">    [SYS_exec] sys_exec,</span><br><span class="line">    [SYS_fstat] sys_fstat,</span><br><span class="line">    [SYS_chdir] sys_chdir,</span><br><span class="line">    [SYS_dup] sys_dup,</span><br><span class="line">    [SYS_getpid] sys_getpid,</span><br><span class="line">    [SYS_sbrk] sys_sbrk,</span><br><span class="line">    [SYS_sleep] sys_sleep,</span><br><span class="line">    [SYS_uptime] sys_uptime,</span><br><span class="line">    [SYS_open] sys_open,</span><br><span class="line">    [SYS_write] sys_write,</span><br><span class="line">    [SYS_mknod] sys_mknod,</span><br><span class="line">    [SYS_unlink] sys_unlink,</span><br><span class="line">    [SYS_link] sys_link,</span><br><span class="line">    [SYS_mkdir] sys_mkdir,</span><br><span class="line">    [SYS_close] sys_close,</span><br><span class="line">    [SYS_trace] sys_trace, <span class="comment">// (new)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>step 4：<br>在 <code>user/usys.pl</code> 中对新的系统调用使用 <code>entry()</code>，使得在生成的 <code>user/usys.S</code> 中有系统调用的汇编代码</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.pl</span></span><br><span class="line"></span><br><span class="line">entry(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exit&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mknod&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;fstat&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;getpid&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sbrk&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line">entry(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/usys.S</span></span><br><span class="line"></span><br><span class="line">write:</span><br><span class="line">li a7, SYS_write</span><br><span class="line">ecall</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>step 5：</p><p>最后在 user/user.h 中添加系统调用函数的声明</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/user.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// system calls</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> **)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mknod</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">short</span>, <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">uptime</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trace</span><span class="params">(<span class="type">int</span>)</span>; <span class="comment">// (new)</span></span><br></pre></td></tr></table></figure><h2 id="System-call-tracing-moderate">System call tracing (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h2><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs.<br>You’ll <strong>create a new trace system call</strong> that will control tracing.<br>It should take <strong>one argument</strong>, an integer “mask”, whose bits specify which system calls to trace.<br>For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h.<br>You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask.<br>The line should <strong>contain the process id, the name of the system call and the return value</strong>;<br>you don’t need to print the system call arguments.<br>The trace system call should enable tracing for the process that calls it and <strong>any children</strong> that it subsequently forks, but should not affect other processes.</p></blockquote><p>新增一个 system call，用于输出将执行的任务都调用了哪些系统调用<br>注意需要也要输出 fork 出的子进程的系统调用</p><ul><li>输入：<ul><li>其接受一个参数 mask 用于制定哪些系统调用要输出</li></ul></li><li>输出：<ul><li>process id</li><li>system call name</li><li>return value</li></ul></li></ul><figure class="highlight bash"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 966</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 70</span><br><span class="line">3: syscall <span class="built_in">read</span> -&gt; 0</span><br></pre></td></tr></table></figure><h3 id="具体实施">具体实施</h3><h4 id="step-1：在-PCB-中添加存储-mask-的-syscall-trace，以及为-syscall-trace-赋初始值-0">step 1：在 <code>PCB</code> 中添加存储 <code>mask</code> 的 <code>syscall_trace</code>，以及为 <code>syscall_trace</code> 赋初始值 <code>0</code></h4><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span> <span class="comment">// Process state</span></span><br><span class="line">    <span class="type">void</span> *chan;           <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">    <span class="type">int</span> killed;           <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">    <span class="type">int</span> xstate;           <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">    <span class="type">int</span> pid;              <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">    uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">    uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">    uint64 syscall_trace;        <span class="comment">// (new) 用于记录哪些 syscall 需要被追踪</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="step-2：添加-uint64-sys-trace-void">step 2：添加 <code>uint64 sys_trace(void)</code></h4><p>获取 <code>system call</code> 的参数 <code>mask</code> ，将其写到到进程表中 <code>syscall_trace</code><br><code>syscall_trace</code> 是我们在进程表 PCB 中手动加的一个新数据</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"></span><br><span class="line">uint64 <span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">    argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line"></span><br><span class="line">    myproc()-&gt;syscall_trace = mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到的 <code>argint</code> 来获取 <code>system call</code> 的参数<br><code>argint</code> 通过 <code>argraw</code> 访问到 <code>trapframe</code> 来获得参数</p><blockquote><p>#os/q:</p></blockquote><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span> &#123;</span><br><span class="line">    *ip = argraw(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> uint64 <span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="step-3：修改-fork-函数，使得-syscall-trace-得以继承">step 3：修改 <code>fork</code> 函数，使得 <code>syscall_trace</code> 得以继承</h4><blockquote><p>#os/q</p></blockquote><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new process, copying the parent.</span></span><br><span class="line"><span class="comment">// Sets up child kernel stack to return as if from fork() system call.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, pid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">np</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate process.</span></span><br><span class="line">    <span class="keyword">if</span> ((np = allocproc()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        freeproc(np);</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    np-&gt;sz = p-&gt;sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy saved user registers.</span></span><br><span class="line">    *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">    np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increment reference counts on open file descriptors.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ofile[i])</span><br><span class="line">            np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">    np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line"></span><br><span class="line">    safestrcpy(np-&gt;name, p-&gt;name, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line"></span><br><span class="line">    np-&gt;syscall_trace = p-&gt;syscall_trace; <span class="comment">// (new)</span></span><br><span class="line"></span><br><span class="line">    pid = np-&gt;pid;</span><br><span class="line"></span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;wait_lock);</span><br><span class="line">    np-&gt;parent = p;</span><br><span class="line">    release(&amp;wait_lock);</span><br><span class="line"></span><br><span class="line">    acquire(&amp;np-&gt;lock);</span><br><span class="line">    np-&gt;state = RUNNABLE;</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="step-4：所有的系统调用都会进入-syscall-函数，我们在这里进行追踪">step 4：所有的系统调用都会进入 <code>syscall</code> 函数，我们在这里进行追踪</h4><p>因为要输出 <code>syscall</code> 对应的名字（字符串），所以我们可以现在 <code>kernel/syscall.h</code> 中定义一个字符串数组 <code>syscall_names[]</code></p><blockquote><p>#os/q 注意：这个字符数组映射的功能好像在 c++ 中取消了？<br>#os/q 为什么字符数组映射不能存在 <code>syscall.h</code> 中</p></blockquote><p><img src="../assets/image-20240321183126050.png" alt=""></p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *syscall_names[] = &#123;</span><br><span class="line">    [SYS_fork] <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">    [SYS_exit] <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">    [SYS_wait] <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">    [SYS_pipe] <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">    [SYS_read] <span class="string">&quot;read&quot;</span>,</span><br><span class="line">    [SYS_kill] <span class="string">&quot;kill&quot;</span>,</span><br><span class="line">    [SYS_exec] <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">    [SYS_fstat] <span class="string">&quot;fstat&quot;</span>,</span><br><span class="line">    [SYS_chdir] <span class="string">&quot;chdir&quot;</span>,</span><br><span class="line">    [SYS_dup] <span class="string">&quot;dup&quot;</span>,</span><br><span class="line">    [SYS_getpid] <span class="string">&quot;getpid&quot;</span>,</span><br><span class="line">    [SYS_sbrk] <span class="string">&quot;sbrk&quot;</span>,</span><br><span class="line">    [SYS_sleep] <span class="string">&quot;sleep&quot;</span>,</span><br><span class="line">    [SYS_uptime] <span class="string">&quot;uptime&quot;</span>,</span><br><span class="line">    [SYS_open] <span class="string">&quot;open&quot;</span>,</span><br><span class="line">    [SYS_write] <span class="string">&quot;write&quot;</span>,</span><br><span class="line">    [SYS_mknod] <span class="string">&quot;mknod&quot;</span>,</span><br><span class="line">    [SYS_unlink] <span class="string">&quot;unlink&quot;</span>,</span><br><span class="line">    [SYS_link] <span class="string">&quot;link&quot;</span>,</span><br><span class="line">    [SYS_mkdir] <span class="string">&quot;mkdir&quot;</span>,</span><br><span class="line">    [SYS_close] <span class="string">&quot;close&quot;</span>,</span><br><span class="line">    [SYS_trace] <span class="string">&quot;trace&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/syscall.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">    num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">        <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">        <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (new)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;syscall_trace &amp; (<span class="number">1</span> &lt;&lt; num)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">               p-&gt;pid, p-&gt;name, num);</span><br><span class="line">        p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果">运行结果</h4><figure class="highlight bash"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 961</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 321</span><br><span class="line">11: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">$ trace 2147483647 grep hello README</span><br><span class="line">12: syscall trace -&gt; 0</span><br><span class="line">12: syscall <span class="built_in">exec</span> -&gt; 3</span><br><span class="line">12: syscall open -&gt; 3</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 1023</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 961</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 321</span><br><span class="line">12: syscall <span class="built_in">read</span> -&gt; 0</span><br><span class="line">12: syscall close -&gt; 0</span><br><span class="line">$ trace 2 usertests forkforkfork</span><br><span class="line">usertests starting</span><br><span class="line">13: syscall fork -&gt; 14</span><br><span class="line"><span class="built_in">test</span> forkforkfork: 13: syscall fork -&gt; 15</span><br><span class="line">15: syscall fork -&gt; 16</span><br><span class="line">16: syscall fork -&gt; 17</span><br><span class="line">16: syscall fork -&gt; 18</span><br><span class="line">17: syscall fork -&gt; 19</span><br><span class="line">18: syscall fork -&gt; 20</span><br><span class="line">16: syscall fork -&gt; 21</span><br><span class="line">17: syscall fork -&gt; 22</span><br><span class="line">18: syscall fork -&gt; 23</span><br><span class="line">16: syscall fork -&gt; 24</span><br><span class="line">19: syscall fork -&gt; 25</span><br><span class="line">20: syscall fork -&gt; 26</span><br><span class="line">16: syscall fork -&gt; 27</span><br><span class="line">17: syscall fork -&gt; 28</span><br><span class="line">19: syscall fork -&gt; 29</span><br><span class="line">18: syscall fork -&gt; 30</span><br><span class="line">16: syscall fork -&gt; 31</span><br><span class="line">19: syscall fork -&gt; 32</span><br><span class="line">17: syscall fork -&gt; 33</span><br><span class="line">16: syscall fork -&gt; 34</span><br><span class="line">19: syscall fork -&gt; 35</span><br><span class="line">17: syscall fork -&gt; 36</span><br><span class="line">16: syscall fork -&gt; 37</span><br><span class="line">19: syscall fork -&gt; 38</span><br><span class="line">17: syscall fork -&gt; 39</span><br><span class="line">18: syscall fork -&gt; 40</span><br><span class="line">19: syscall fork -&gt; 41</span><br><span class="line">16: syscall fork -&gt; 42</span><br><span class="line">18: syscall fork -&gt; 43</span><br><span class="line">19: syscall fork -&gt; 44</span><br><span class="line">17: syscall fork -&gt; 45</span><br><span class="line">16: syscall fork -&gt; 46</span><br><span class="line">19: syscall fork -&gt; 47</span><br><span class="line">17: syscall fork -&gt; 48</span><br><span class="line">16: syscall fork -&gt; 49</span><br><span class="line">18: syscall fork -&gt; 50</span><br><span class="line">19: syscall fork -&gt; 51</span><br><span class="line">16: syscall fork -&gt; 52</span><br><span class="line">17: syscall fork -&gt; 53</span><br><span class="line">18: syscall fork -&gt; 54</span><br><span class="line">16: syscall fork -&gt; 55</span><br><span class="line">17: syscall fork -&gt; 56</span><br><span class="line">20: syscall fork -&gt; 57</span><br><span class="line">19: syscall fork -&gt; 58</span><br><span class="line">17: syscall fork -&gt; 59</span><br><span class="line">16: syscall fork -&gt; 60</span><br><span class="line">18: syscall fork -&gt; 61</span><br><span class="line">19: syscall fork -&gt; 62</span><br><span class="line">17: syscall fork -&gt; 63</span><br><span class="line">18: syscall fork -&gt; 64</span><br><span class="line">16: syscall fork -&gt; 65</span><br><span class="line">19: syscall fork -&gt; 66</span><br><span class="line">17: syscall fork -&gt; 67</span><br><span class="line">18: syscall fork -&gt; 68</span><br><span class="line">16: syscall fork -&gt; 69</span><br><span class="line">19: syscall fork -&gt; 70</span><br><span class="line">17: syscall fork -&gt; 71</span><br><span class="line">18: syscall fork -&gt; 72</span><br><span class="line">16: syscall fork -&gt; 73</span><br><span class="line">19: syscall fork -&gt; 74</span><br><span class="line">18: syscall fork -&gt; 75</span><br><span class="line">16: syscall fork -&gt; -1</span><br><span class="line">17: syscall fork -&gt; -1</span><br><span class="line">19: syscall fork -&gt; -1</span><br><span class="line">18: syscall fork -&gt; -1</span><br><span class="line">20: syscall fork -&gt; -1</span><br><span class="line">OK</span><br><span class="line">13: syscall fork -&gt; 76</span><br><span class="line">ALL TESTS PASSED</span><br></pre></td></tr></table></figure><h2 id="Sysinfo-moderate">Sysinfo (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h2><blockquote><p>In this assignment you will <strong>add a system call</strong>, sysinfo, that collects information about the running system.<br>The system call takes <strong>one argument</strong>: a pointer to a struct sysinfo (see kernel/sysinfo.h).<br>The kernel should fill out the fields of this struct: <strong>the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED.</strong><br>We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p></blockquote><p>在这个作业中，您将添加一个系统调用<code>sysinfo</code>，它收集有关正在运行的系统的信息。<br>系统调用采用一个参数：一个指向<code>struct sysinfo</code>的指针（参见<code>kernel/sysinfo.h</code>）。<br>内核应该填写这个结构的字段：<code>freemem</code>字段应该设置为空闲内存的字节数，<code>nproc</code>字段应该设置为<code>state</code>字段不为<code>UNUSED</code>的进程数。<br>我们提供了一个测试程序<code>sysinfotest</code>；如果输出“<code>sysinfotest: OK</code>”则通过。</p><p>hint</p><ul><li>在**<em>Makefile</em><strong>的</strong>UPROGS**中添加<code>$U/_sysinfotest</code></li><li>当运行<code>make qemu</code>时，**<em>user/sysinfotest.c</em><strong>将会编译失败，遵循和上一个作业一样的步骤添加<code>sysinfo</code>系统调用。要在</strong><em>user/user.h</em>**中声明<code>sysinfo()</code>的原型，需要预先声明<code>struct sysinfo</code>的存在：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysinfo</span><span class="params">(<span class="keyword">struct</span> sysinfo *)</span></span>;</span><br></pre></td></tr></table></figure><p>一旦修复了编译问题，就运行<code>sysinfotest</code>；但由于您还没有在内核中实现系统调用，执行将失败。</p><ul><li><code>sysinfo</code>需要将一个<code>struct sysinfo</code>复制回用户空间；请参阅<code>sys_fstat()</code>(<strong><em>kernel/sysfile.c</em></strong>)和<code>filestat()</code>(<strong><em>kernel/file.c</em></strong>)以获取如何使用<code>copyout()</code>执行此操作的示例。</li><li>要获取空闲内存量，请在**<em>kernel/kalloc.c</em>**中添加一个函数</li><li>要获取进程数，请在**<em>kernel/proc.c</em>**中添加一个函数</li></ul><h3 id="具体实施-2">具体实施</h3><h4 id="step-1：创建-get-free-mem">step 1：创建 <code>get_free_mem</code></h4><p>用来获取当前<strong>空闲内存大小</strong></p><p>在 <code>kernel/defs.h</code> 内核头文件中添加 函数声明</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>            <span class="title function_">procdump</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64          <span class="title function_">get_proc_num</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// (new)</span></span><br></pre></td></tr></table></figure><p>函数实现</p><p><code>xv6</code> 采用的是空闲列表法，把 <code>r</code> 这个列表访问完，看有多少个节点即可<br>每个节点代表一页，大小为 <code>PGSIZE</code> ，<code>4096 KB</code></p><p>注意在操作过程中要加锁</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line">uint64 <span class="title function_">get_free_mem</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    acquire(&amp;kmem.lock); <span class="comment">// 先给内存管理结构加锁</span></span><br><span class="line"></span><br><span class="line">    uint64 mem = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span> =</span> kmem.freelist;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        mem += PGSIZE;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中用到的 <code>run</code> 是指向自己类型的指针，<code>kmem</code> 是一个列表和锁</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/kalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">run</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><h4 id="step-2：创建-get-proc-num">step 2：创建 <code>get_proc_num</code></h4><p>用来获取当前<strong>进行的进程数</strong></p><p>在 <code>kernel/defs.h</code> 内核头文件中添加 函数声明</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/defs.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>*           <span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *)</span>;</span><br><span class="line"><span class="type">void</span>            <span class="title function_">kinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">uint64          <span class="title function_">get_free_mem</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// (new)</span></span><br></pre></td></tr></table></figure><p>函数实现</p><p>统计 <code>proc</code> 中所有非 <code>UNUSED</code> 的状态即可</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line">uint64 <span class="title function_">get_proc_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 cnt_proc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> proc *p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;state != UNUSED) &#123;</span><br><span class="line">            cnt_proc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt_proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 proc 中进程 state 一共有 5 种</p><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/proc.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED,</span><br><span class="line">                 USED,</span><br><span class="line">                 SLEEPING,</span><br><span class="line">                 RUNNABLE,</span><br><span class="line">                 RUNNING,</span><br><span class="line">                 ZOMBIE &#125;;</span><br></pre></td></tr></table></figure><h4 id="step-3：创建系统调用-sysinfo">step 3：创建系统调用 <code>sysinfo</code></h4><p>具体的添加操作和前面 <code>trace</code> 类似，我们主要来看函数实现</p><p>这里主要是用到了 <code>copyout</code> 来实现从内核中把数据复制到用户中（这样子做的原因是，用户和内核数据进行了隔离，需要用相应的函数进行传输 <code>copyin/copyout</code>）</p><blockquote><p>#os/todo 等有时间来详细说下 <code>copyout</code></p></blockquote><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/sysproc.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (new)</span></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    uint64 addr;</span><br><span class="line">    argaddr(<span class="number">0</span>, &amp;addr);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">sinfo</span>;</span></span><br><span class="line">    sinfo.freemem = get_free_mem();</span><br><span class="line">    sinfo.nproc = get_proc_num();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyout(myproc()-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;sinfo, <span class="keyword">sizeof</span>(sinfo)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果-2">运行结果</h4><figure class="highlight c"><figcaption><span>fold</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sysinfotest</span><br><span class="line">sysinfotest: start</span><br><span class="line">sysinfotest: OK</span><br></pre></td></tr></table></figure><h2 id="Conclusion">Conclusion</h2><p>这次的实验感觉已经花费了不少精力，主要在于弄清系统调用是如何一步步的执行的，其中因为用户和内核的隔离又涉及如何进行模式转换 …</p><p>最开始了解系统调用是 csapp 中的 shell lab，当时稀里糊涂的就在使用，根本想不到真正执行到那一点系统调用代码，涉及着这么深的东西。</p><p>amazing ！</p><p>TODO</p><ul><li>完成本文中的 os/todo</li><li>完成本文中的 os/q (question)</li><li>丰富代码的检查机制</li><li>完成选做内容</li></ul><p><img src="../assets/image-20240323151830407.png" alt=""></p><h2 id="Reference">Reference</h2><p><a href="https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/">cs wiki</a></p><p><a href="https://www.bilibili.com/video/BV19k4y1C7kA/?spm_id_from=333.337.search-card.all.click&amp;vd_source=664d223fe65c6706d11206b7416f5b92">MIT6.S081课堂视频</a><br><a href="https://github.com/duguosheng/6.S081-All-in-one">6.S081-All-in-one</a><br><a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081">MIT6.S081 视频记录</a><br><a href="https://xv6.dgs.zone/tranlate_books/book-riscv-rev1/summary.html">BOOK-RISCV-REV1</a></p><p><a href="https://jborza.com/emulation/2021/04/22/ecalls-and-syscalls.html">Misunderstanding RISC-V ecalls and syscalls</a><br><a href="https://www.cnblogs.com/lilpig/p/17168211.html">xv6系统调用流程——MIT6.S081操作系统</a><br><a href="https://doraemonzzz.com/tags/6-S081/">doraemonzzz’s blog</a><br><a href="https://blog.miigon.net/">Miigon’s blog</a><br><a href="https://www.cnblogs.com/weijunji/tag/XV6/">星遥见</a></p>]]></content>
    
    
    <summary type="html">【MIT 6.S081】 Lab2-System calls</summary>
    
    
    
    <category term="OS" scheme="https://devilran6.github.io/categories/OS/"/>
    
    <category term="MIT 6.S081" scheme="https://devilran6.github.io/categories/OS/MIT-6-S081/"/>
    
    
    <category term="系统调用" scheme="https://devilran6.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.S081】 Lab1-Xv6 and Unix utilities</title>
    <link href="https://devilran6.github.io/posts/8b60d190.html"/>
    <id>https://devilran6.github.io/posts/8b60d190.html</id>
    <published>2024-03-07T14:00:00.000Z</published>
    <updated>2024-03-23T10:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>课程地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a><br>Lab 地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">https://pdos.csail.mit.edu/6.S081/2020/labs/util.html</a><br>我的代码地址：<a href="https://github.com/devilran6/devilran-xv6/tree/util">https://github.com/devilran6/devilran-xv6/tree/util</a><br>Commits: <a href="">https://github.com/devilran6/devilran-xv6/commits/util/</a></p></blockquote><h1>Lab1: Xv6 and Unix utilities</h1><p>This lab will familiarize you with xv6 and its system calls.</p><h2 id="Boot-xv6-easy">Boot xv6 (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h2><p><strong>实验环境配置</strong>：</p><ul><li><strong>计算机型号</strong>：MacBook Pro 14英寸</li><li><strong>处理器</strong>：Apple M3</li><li><strong>内存</strong>：16 GB</li><li><strong>操作系统</strong>：macOS Sonoma 版本14.2.1</li><li><strong>存储设备</strong>：512GB</li></ul><h3 id="配置工具链">配置工具链</h3><p><a href="https://pdos.csail.mit.edu/6.S081/2021/tools.html">https://pdos.csail.mit.edu/6.S081/2021/tools.html</a></p><h3 id="启动-Testing-Installation">启动(Testing Installation)</h3><p>最开始使用的是 xv6-labs-2020，可能是 gcc 的版本问题，导致了出现了如下错误</p><p><a href="https://stackoverflow.com/questions/76942822/encountered-problem-installing-xv6-on-my-mac-os">https://stackoverflow.com/questions/76942822/encountered-problem-installing-xv6-on-my-mac-os</a></p><p>之后改成 xv6-labs-2022<br><a href="https://github.com/relaxcn/xv6-labs-2022-solutions?tab=readme-ov-file">https://github.com/relaxcn/xv6-labs-2022-solutions?tab=readme-ov-file</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone git://g.csail.mit.edu/xv6-labs-2022</span><br><span class="line">cd xv6-labs-2022</span><br><span class="line">git checkout util</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure><blockquote><p>output.txt 文件究竟存在于哪里？？？</p></blockquote><h2 id="Grading-and-hand-in-procedure">Grading and hand-in procedure</h2><p>You can run <code>make grade</code> to test your solutions with the grading program</p><h2 id="sleep-easy">sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h2><blockquote><p>Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c.</p></blockquote><p>创建 user/sleep.c 文件，实现暂停指定个时钟周期</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sleep.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep 10\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tm = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(tm);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ps：sleep 需要加入 Makefile 中</li></ul><blockquote><p>ran：这里直接使用 sleep 对吗？ 跳转定义进去存在于 proc.c 这个很像信号锁部分的内容？<br><img src="../assets/image-20240304193228854.png" alt="">&gt;</p></blockquote><h2 id="pingpong-easy">pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h2><p>用 pipe 创建管道，实现在父进程和子进程中传递一个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pingpong.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: pingpong\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p_p2c[<span class="number">2</span>], p_c2p[<span class="number">2</span>];</span><br><span class="line">    pipe(p_p2c);</span><br><span class="line">    pipe(p_c2p);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(p_p2c[<span class="number">1</span>]);</span><br><span class="line">        close(p_c2p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf;</span><br><span class="line">        read(p_p2c[<span class="number">0</span>], &amp;buf, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child receive: %c\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        write(p_c2p[<span class="number">1</span>], <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        close(p_p2c[<span class="number">0</span>]);</span><br><span class="line">        close(p_c2p[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        close(p_p2c[<span class="number">0</span>]);</span><br><span class="line">        close(p_c2p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        write(p_p2c[<span class="number">1</span>], <span class="string">&quot;p&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf;</span><br><span class="line">        read(p_c2p[<span class="number">0</span>], &amp;buf, <span class="number">1</span>);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent receive: %c\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        close(p_p2c[<span class="number">1</span>]);</span><br><span class="line">        close(p_c2p[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="../BOOK-RISCV-REV1.md#c1s3%20%E7%AE%A1%E9%81%93">c1s3 管道</a></p><p><strong>ran1</strong><br>刚开始没反应过来是用两个管道，在想用一个管道，怎么样才能实现来回等待。<br>并且因为父、子进程都需要收、发，所以所有的通道都不能关上，这样如果两边同时输入很可能出问题<br>（也不好用代码控制不同时输入，sleep？）</p><p><strong>ran2</strong><br>在父进程和子进程的入口处，我首先关闭了不需要的读写窗口。<br>我这样做出发的角度是“关闭不需要的端口”，不知道是否合理？</p><p><strong>ran3</strong><br>检查了一下，发现把输入输出端搞错了，这个是通过，我多加的代码（分别输出两个进程通过管道接受到的字节）发现的<br>正确的应该是:<br><code>write(p[1], ...)</code><br><code>read(p[0], ...)</code></p><p><img src="../assets/image-20240305015152566.png" alt=""></p><p><img src="../assets/image-20240305015211455.png" alt=""></p><p><strong>ran4</strong> 关于管道</p><ul><li><strong>数据的读取和写入是阻塞的</strong>：如果管道空了，读操作会阻塞，直到有数据写入。同样，如果管道的数据没有被读取，写操作可能也会阻塞，直到有足够的空间来存储待写入的数据。</li><li><strong>管道的生命周期</strong>：管道在创建它的进程以及其子进程中存在。当所有相关的文件描述符都被关闭后，管道会被销毁。</li></ul><p><strong>ran5</strong><br>由于只能父进程等待子进程，而子进程不能等待父进程。<br>为了让父进程和子进程的输出不混乱到一起（因为我们无法保证两个“同时”执行在一个 cpu 上的进程，究竟是哪个进程先执行）<br>在父进程中，我先使用了 wait(0)，之后再 printf 的。</p><h2 id="primes-moderate-hard">primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)/(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</h2><p>Write a concurrent version of prime sieve using pipes.</p><p>用管道编写并发版本的素数筛（埃氏筛）</p><p><a href="https://swtch.com/~rsc/thread/">intro</a></p><p><img src="../assets/image-20240307224843714.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primes.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> left_pipe[<span class="number">2</span>])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    read(left_pipe[<span class="number">0</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// fprintf(2, &quot;? =&gt; %d\n&quot;, getpid());</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> base_prime = i;</span><br><span class="line">    <span class="type">int</span> right_pipe[<span class="number">2</span>];</span><br><span class="line">    pipe(right_pipe);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(right_pipe[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        close(left_pipe[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        foo(right_pipe);</span><br><span class="line"></span><br><span class="line">        close(right_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        <span class="comment">// fprintf(2, &quot;parent: %d, child: %d\n&quot;, getpid(), pid);</span></span><br><span class="line">        close(right_pipe[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (read(left_pipe[<span class="number">0</span>], &amp;i, <span class="keyword">sizeof</span>(i)) &amp;&amp; i != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % base_prime != <span class="number">0</span>) &#123;</span><br><span class="line">                write(right_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        i = <span class="number">-1</span>;</span><br><span class="line">        write(right_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line"></span><br><span class="line">        close(right_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: primes\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> input_pipe[<span class="number">2</span>];</span><br><span class="line">    pipe(input_pipe);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        close(input_pipe[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line"></span><br><span class="line">        foo(input_pipe);</span><br><span class="line"></span><br><span class="line">        close(input_pipe[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        close(input_pipe[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">            write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哨兵</span></span><br><span class="line">        i = <span class="number">-1</span>;</span><br><span class="line">        write(input_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line"></span><br><span class="line">        close(input_pipe[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>ran1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i</span><br><span class="line"><span class="title function_">for</span><span class="params">(i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++)</span></span><br><span class="line">pass</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i ++)</span><br><span class="line">pass</span><br></pre></td></tr></table></figure><p>上面这两种有什么区别吗，第一种会在效率 or 空间上效果更好？<br>我看有一些代码文件采取的是前者，而我自己一直使用的是后者</p><p><strong>ran2</strong></p><p>这个是真的不太好写，我第一次传参的时候只传读的管道，但是会卡主（所有进程最后不会退出），没太想明白什么原因<br>目前猜测是 哪里 write 或 read 阻塞的问题？</p><p><code>void foo(int read_pipe)</code><br>改成下面<br><code>void foo(int left_pipe[2])</code><br>后可以了</p><p>我最开始不想使用下面的原因是，我想着他是个数组，传参只是把首地址传了过来，并没有真正复制一个数。</p><p>咦，会不会 上面出现问题，是因为复制了一个 文件符，关闭的时候，只是把复制的关闭了，原来的没关闭。<br>但是如果传数组的话，就直接关闭了？</p><h2 id="find-moderate">find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h2><p>find all the files in a directory tree with a specific name.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最后的文件名，返回固定长度字符串 DIRSIZ</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> buf[DIRSIZ + <span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = path + <span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">        ;</span><br><span class="line">    p++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(p) &gt;= DIRSIZ)</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    memmove(buf, p, <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(buf + <span class="built_in">strlen</span>(p), <span class="string">&#x27; &#x27;</span>, DIRSIZ - <span class="built_in">strlen</span>(p));</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="comment">// fprintf(2, &quot;------ In Func find, path = %s, filename = %s\n&quot;, path, filename);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fprintf(2, &quot;st.type = %d\n&quot;, st.type);</span></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">        <span class="comment">// fprintf(2, &quot;<span class="doctag">TODO:</span> type = T_DEVICE\n&quot;);</span></span><br><span class="line">    <span class="keyword">case</span> T_FILE:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="built_in">strlen</span>(path) - <span class="built_in">strlen</span>(filename), filename) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_DIR:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">        p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">        *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// p 的位置在 buf 的结尾，所以复制到 p，即复制到 buf 结尾</span></span><br><span class="line">            memmove(p, de.name, DIRSIZ);</span><br><span class="line">            p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fprintf(2, &quot;de.name = %s\n&quot;, de.name);</span></span><br><span class="line">            <span class="comment">// fprintf(2, &quot;p       = %s\n&quot;, p);</span></span><br><span class="line">            <span class="comment">// fprintf(2, &quot;buf     = %s\n&quot;, buf);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stat(buf, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buf + <span class="built_in">strlen</span>(buf) - <span class="number">1</span>, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(buf + <span class="built_in">strlen</span>(buf) - <span class="number">2</span>, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">                find(buf, filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: no type\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find &lt;path&gt; &lt;filename&gt;&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_37926485/article/details/122804385">fstat</a></p><p>模仿 ls.c 写即可</p><p>观察一下 stat.h 这是用来一个文件/文件夹名称的信息的</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stat.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DIR     1   <span class="comment">// Directory</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_FILE    2   <span class="comment">// File</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_DEVICE  3   <span class="comment">// Device</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> dev;     <span class="comment">// File system&#x27;s disk device</span></span><br><span class="line">  uint ino;    <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">short</span> type;  <span class="comment">// Type of file</span></span><br><span class="line">  <span class="type">short</span> nlink; <span class="comment">// Number of links to file</span></span><br><span class="line">  uint64 size; <span class="comment">// Size of file in bytes</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ran1</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        ls(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        ls(argv[i]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看了 user/ls.c 后才发现 ls 指令可以一下展开多个目录！</p><p><strong>ran2</strong></p><p>字符串比较要用 strcmp !!<br>前面想着用 <code>strcmp</code> 来着，后面直接写成 <code>if(str1 != str2)</code> 了， 哈哈哈</p><p><img src="../assets/image-20240307183341959.png" alt=""></p><p><strong>ran3</strong><br>望周知，还在奇怪代码和 ls.c 的基本一样，但字符串处理完输出不一样<br><img src="../assets/image-20240307192918053.png" alt=""></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> = buf + sizeof(buf)</span><br><span class="line"><span class="attr">p</span> = buf + strlen(buf)</span><br></pre></td></tr></table></figure><p>p 是要跳到 buf 的结尾，应该是加长度，不是加大小啊！</p><p><strong>ran4</strong><br>注意  文件符号数量是有限的，一定要记得关，否则后面的就打不开了<br><code>close(fd)</code></p><p><img src="../assets/image-20240307195820419.png" alt=""></p><h2 id="xargs-moderate">xargs (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h2><p>xargs介绍：</p><p><a href="https://wangchujiang.com/linux-command/c/xargs.html">https://wangchujiang.com/linux-command/c/xargs.html</a></p><p>read lines from the standard input and run a command for each line, supplying the line as arguments to the command.</p><p>从标准读入中读取数据，作为后面的参数，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span></span><br><span class="line">bye hello too</span><br><span class="line"><span class="meta prompt_">$</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xargs.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy</span><span class="params">(<span class="type">char</span> **p1, <span class="type">char</span> *p2)</span> &#123;</span><br><span class="line">    *p1 = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(p2) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(*p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readLine</span><span class="params">(<span class="type">char</span> *pargs[], <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFSIZ = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从标准输入读一行，一个字节一个字节读</span></span><br><span class="line">    <span class="keyword">while</span> (read(<span class="number">0</span>, buf + pos, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[pos] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            buf[pos] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">if</span> (pos == BUFSIZ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: parameters too long!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; pos) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; MAXARG) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: too much parameters\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略前置空格</span></span><br><span class="line">        <span class="keyword">while</span> ((k &lt; pos) &amp;&amp; (buf[k] == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> st = k;</span><br><span class="line">        <span class="keyword">while</span> ((k &lt; pos) &amp;&amp; (buf[k] != <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">            k++;</span><br><span class="line"></span><br><span class="line">        buf[k++] = <span class="number">0</span>;</span><br><span class="line">        copy(&amp;pargs[i], buf + st);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">(<span class="type">char</span> *program, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line">        <span class="keyword">if</span> (exec(program, argv) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: exec failed\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        <span class="comment">// wait(0); 到 main 里面最后等待</span></span><br><span class="line">        <span class="comment">// 这里应该不要 exit(0), 父进程可能从函数返回后还有要执行的内容</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;xargs: need more parameters!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> *pargs[MAXARG];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        copy(&amp;pargs[i - <span class="number">1</span>], argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">while</span> ((end = readLine(pargs, argc - <span class="number">1</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        pargs[end] = <span class="number">0</span>;</span><br><span class="line">        run(pargs[<span class="number">0</span>], pargs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Time-spent-所花费的时间">Time spent  所花费的时间</h2><p>Create a new file, time.txt, and put in it a single integer, the number of hours you spent on the lab. Don’t forget to git add and git commit the file.<br>创建一个新文件 time.txt ，并在其中放入一个整数，即您在实验室上花费的小时数。不要忘记 git add 和 git commit 文件。</p><p>刚开始没注意到这个 99（<br><img src="../assets/image-20240307215716603.png" alt=""></p><p><img src="../source/assets/image-20240307215716603.png" alt=""></p><h2 id="Conclusion">Conclusion</h2><p>完成了基本的功能，通过了脚本检查，但是代码也不一定正确，等选做等做完后面的实验回过头来再看一看</p><p><strong>TODO</strong></p><ul><li>丰富代码的检查机制</li><li>完成选做内容</li></ul><p><img src="../assets/image-20240307215758225.png" alt=""></p>]]></content>
    
    
    <summary type="html">【MIT 6.S0811 Lab1-Xv6 and Unix utilities</summary>
    
    
    
    <category term="OS" scheme="https://devilran6.github.io/categories/OS/"/>
    
    <category term="MIT 6.S081" scheme="https://devilran6.github.io/categories/OS/MIT-6-S081/"/>
    
    
  </entry>
  
  <entry>
    <title>OS之旅</title>
    <link href="https://devilran6.github.io/posts/234539a9.html"/>
    <id>https://devilran6.github.io/posts/234539a9.html</id>
    <published>2024-02-29T16:00:00.000Z</published>
    <updated>2024-03-01T14:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>OS 之旅</h1><p>MIT 6.S801</p><p>从 CSAPP shell lab 中稀里糊涂的用系统调用，<br>到 MIT 6.S801 lab2 了解是如何从用户态切换到内核态，一层一层的调用，执行到真正的内核中的代码</p><p>amazing!</p>]]></content>
    
    
    <summary type="html">OS之旅</summary>
    
    
    
    <category term="OS" scheme="https://devilran6.github.io/categories/OS/"/>
    
    
  </entry>
  
  <entry>
    <title>有意思的网站</title>
    <link href="https://devilran6.github.io/posts/5c37860b.html"/>
    <id>https://devilran6.github.io/posts/5c37860b.html</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2024-03-23T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://wdxtub.com/">https://wdxtub.com/</a></p><p><a href="https://blog.tonycrane.cc/">https://blog.tonycrane.cc/</a></p><p><a href="https://note.tonycrane.cc/">https://note.tonycrane.cc/</a></p>]]></content>
    
    
    <summary type="html">有意思的网站</summary>
    
    
    
    <category term="Blog" scheme="https://devilran6.github.io/categories/Blog/"/>
    
    
  </entry>
  
  <entry>
    <title>ICPC网络赛第二场</title>
    <link href="https://devilran6.github.io/posts/7869750000.html"/>
    <id>https://devilran6.github.io/posts/7869750000.html</id>
    <published>2023-09-30T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:58.503Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>Code Reference：</p><p><a href="https://zhuanlan.zhihu.com/p/658033297">https://zhuanlan.zhihu.com/p/658033297</a></p><p><a href="https://blog.csdn.net/qq_62817228/article/details/133214071">https://blog.csdn.net/qq_62817228/article/details/133214071</a></p></div><div class="note success flat"><p>！！！</p></div><h2 id="K-Super-Knight">K Super-Knight</h2><p>n * n的棋盘，上下连接，左右连接。</p><p>棋子最开始在左下角，每移动一次会向上移动a，向右移动b</p><p>问除了出发点外所有可以到达的点中，距离出发点的欧几里得距离的平方的最小值为多少</p><p><strong>思路：</strong></p>]]></content>
    
    
    <summary type="html">ICPC网络赛第二场</summary>
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    
  </entry>
  
  <entry>
    <title>CF数学</title>
    <link href="https://devilran6.github.io/posts/aa579273.html"/>
    <id>https://devilran6.github.io/posts/aa579273.html</id>
    <published>2023-09-27T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:55.612Z</updated>
    
    <content type="html"><![CDATA[<h1>RWADME</h1><h2 id="1542B">1542B</h2><h3 id="题目">题目</h3><ul><li>1 在集合中</li><li>给定 a 和 b ,如果 x 在集合中,那么 x*a 和 x+b 也在集合里</li></ul><p>多组测试 问给定 n, a, b, n是否在集合中</p><h3 id="思路">思路</h3><p>观察模数,加 b 不能改变 mod b 的值, 所以 n mod b 出现的模数智能通过 乘a来进行调整.</p><p>a(a + (ab + b)) = a^2 + (a^2 + a) * b发现只会只有a^k这一项 mod b != 0</p><p>代码 =&gt; 找到 (a^k mod b == n mod b &amp;&amp; a^k &lt;= n) 最小的k, 如果没有则不存在</p><p>注意特判</p><ul><li><p>a == 1时, a^k &lt;= n 永远不会跳出循环</p></li><li><p>b == 1时, 任意数都成立</p></li></ul><h3 id="code">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ok = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % b == <span class="number">1</span>)</span><br><span class="line">            ok = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % b == n % b)</span><br><span class="line">            &#123;</span><br><span class="line">                ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1538F">1538F</h2><h3 id="题目-2">题目</h3><p>给你两个整数 $l$和 $r$，其中 $l \lt r$。我们将在$l$的基础上加上$1$，直到结果等于$r$。因此，正好会进行 $r-l$ 次加法运算。对于每一个这样的加法，让我们来看看在它之后将被改变的位数。</p><p>例如</p><ul><li>如果$l=909$，那么加 1 将导致$910$和$2$位数发生变化；</li><li>如果在$l=9$后面加 1，结果将是$10$，并且$2$位数字也将改变；</li><li>如果在$l=489999$后面加 1，结果将是$490000$，$5$位数也将改变。</li></ul><p>更改后的位数总是构成以十进制书写的结果的后缀。</p><p>如果要从$l$得到$r$，每次加上$1$，则输出更改后的位数总数。</p><h3 id="思路-2">思路</h3><p>将 l ~ r 转化为计算 fun® - fun(l)</p><p>fun(x) 为计算 1 ~ x 的变换次数</p><p>对于 fun(x): 针对每一位进行考虑, 有多少个这个位置的变动就等于把这位变成个位之后有多少个数</p><h3 id="code-2">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        res += x;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun</span>(r) - <span class="built_in">fun</span>(l) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1487D">1487D</h2><h2 id="235A">235A</h2><h2 id="1349A">1349A</h2><h2 id="1458A">1458A</h2><p>You are given two positive integer sequences $a_1, \ldots, a_n$ and $b_1, \ldots, b_m$. For each $j = 1, \ldots, m$ find the greatest common divisor of $a_1 + b_j, \ldots, a_n + b_j$.</p><p><strong>思路：</strong></p><p>根据 gcd(a, b) = gcd(a, b - a) 来进行化简</p><p>gcd(a1 + bj, a2 + bj, …, an + bj)</p><p>= gcd(a1 + bj, a2 - a1, a3 - a1, … an - a1)</p><p>= gcd(a1 + bj, w)</p><p>预处理出w即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !b ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;LL&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a[<span class="number">1</span>] + b[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL w = a[<span class="number">2</span>] - a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        w = <span class="built_in">gcd</span>(w, a[i] - a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">abs</span>(<span class="built_in">gcd</span>(a[<span class="number">1</span>] + b[i], w)) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">codeforces 数学 1500-1800</summary>
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    <category term="ACM-Math" scheme="https://devilran6.github.io/categories/ICPC/ACM-Math/"/>
    
    
  </entry>
  
  <entry>
    <title>换根DP</title>
    <link href="https://devilran6.github.io/posts/4286fd48.html"/>
    <id>https://devilran6.github.io/posts/4286fd48.html</id>
    <published>2023-09-27T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:43.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="换根DP">换根DP</h2><p>参考博客<a href="https://zhuanlan.zhihu.com/p/348349531">https://zhuanlan.zhihu.com/p/348349531</a></p><h2 id="题目">题目</h2><h3 id="题目1-洛谷P3478">题目1 洛谷P3478</h3><p><a href="https://www.luogu.com.cn/problem/P3478">https://www.luogu.com.cn/problem/P3478</a></p><h3 id="题目2-div2-899-D">题目2 div2_899_D</h3><p><a href="https://codeforces.com/contest/1882/problem/D">https://codeforces.com/contest/1882/problem/D</a></p>]]></content>
    
    
    <summary type="html">换根DP</summary>
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    <category term="DP" scheme="https://devilran6.github.io/categories/ICPC/DP/"/>
    
    
  </entry>
  
  <entry>
    <title>codeforces</title>
    <link href="https://devilran6.github.io/posts/4841faa2.html"/>
    <id>https://devilran6.github.io/posts/4841faa2.html</id>
    <published>2023-09-26T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:38.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CF’s-note">CF’s note</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CF’s-note&quot;&gt;CF’s note&lt;/h2&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    <category term="CF" scheme="https://devilran6.github.io/categories/ICPC/CF/"/>
    
    
  </entry>
  
  <entry>
    <title>CFdiv2_899</title>
    <link href="https://devilran6.github.io/posts/9f0da27b.html"/>
    <id>https://devilran6.github.io/posts/9f0da27b.html</id>
    <published>2023-09-24T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:29.938Z</updated>
    
    <content type="html"><![CDATA[<p>赛时写了ABCD，但C题卡了太久，b题其实完全暴力就可以，但是想歪了，最后也没时间重新写了，过了ACD</p><h2 id="A">A</h2><h3 id="题目">题目</h3><p>You are given a sequence $a_{1}, a_{2}, \ldots, a_{n}$. A sequence $b_{1}, b_{2}, \ldots, b_{n}$ is called good, if it satisfies all of the following conditions:</p><ul><li>$b_{i}$ is a positive integer for $i = 1, 2, \ldots, n$;</li><li>$b_{i} \neq a_{i}$ for $i = 1, 2, \ldots, n$;</li><li>$b_{1} \lt; b_{2} \lt; \ldots \lt; b_{n}$.</li></ul><p>Find the minimum value of $b_{n}$ among all good sequences $b_{1}, b_{2}, \ldots, b_{n}$.</p><p>给定a序列，求满足条件的最小$b_n$</p><h3 id="思路">思路</h3><p>n很小，直接从t=1开始对应到b就行，如果 $b_i$==$a_i$ , t ++;</p><h3 id="code">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;LL&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>, now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (now == a[i])</span><br><span class="line">            now++;</span><br><span class="line">        ans += now;</span><br><span class="line">        now++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    now--;</span><br><span class="line">    cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>这道题n很小，其实直接暴力就可以，根本不需要思考方</p><h3 id="题目-2">题目</h3><p>给定n个集合$S_i$, 记所有集合的并集为$S_{all}$, 求从中选取一些集合,这些集合的并集的元素数量需要严格小于$S_{all}$,求选取出来的集合的并集的元素数量的最大值</p><h3 id="思路-2">思路</h3><p>挨个枚举全集中的每个元素，当这个元素不存在的时候，我可以把哪些集合进行合并。之后合并完最大值就行</p><h3 id="code-2">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; mp[N], all;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    all.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        mp[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t;</span><br><span class="line">            cin &gt;&gt; t;</span><br><span class="line">            mp[i].<span class="built_in">insert</span>(t);</span><br><span class="line">            all.<span class="built_in">insert</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : all)</span><br><span class="line">    &#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp[i].<span class="built_in">find</span>(t) != mp[i].<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> tt : mp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">insert</span>(tt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)res.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><h3 id="题目-3">题目</h3><p>有n张牌堆成一堆，每张牌上写了一个价值，有以下两个操作，求操作完可以获得的最大价值。任意时候都可以停止操作。（价值中存在负数，否则就全取完就好了）</p><p>操作 — 从上向下数第几张</p><ul><li>拿走第奇数张，之后获得这张牌上的价值</li><li>拿走第偶数张，之后直接将这张牌扔掉，并不获得这张牌的价值</li></ul><p>注意，每次拿走一站牌后，所有牌的顺序会重新计算，奇偶性可能发生改变</p><h3 id="思路-3">思路</h3><p>如果一定选取第i个元素</p><p>对于i后面的奇数位置的元素，可以倒着直接取完</p><p>对于i后面偶数位置的元素，可以取完i，之后后这些要取的元素，就变成奇数了</p><p>后缀和优化</p><p>所以枚举第一个要选取的元素即可</p><h3 id="code-3">code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;LL&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">suf</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suf[n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        suf[i] = suf[i + <span class="number">1</span>] + <span class="built_in">max</span>(a[i], <span class="number">0ll</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, (i % <span class="number">2</span> == <span class="number">1</span>) * a[i] + suf[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">(ABCDEF)</summary>
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    <category term="CF" scheme="https://devilran6.github.io/categories/ICPC/CF/"/>
    
    
  </entry>
  
  <entry>
    <title>CFedu_155</title>
    <link href="https://devilran6.github.io/posts/d7783771.html"/>
    <id>https://devilran6.github.io/posts/d7783771.html</id>
    <published>2023-09-23T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:33.720Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>Code Reference：jiangly</p></div><div class="note success flat"><p>赛时过了ABC。 D题是经典题，循环里没有清零导致赛后才a</p></div><h2 id="A-Rigged">A. Rigged!</h2><p>举重 每个人有一个可以举起来的重量值s和次数e</p><p>问使得第一个人赢,比赛的重量设置为多少？不行输出 -1<br>s<br><strong>思路：</strong></p><p>最优：按照第一个人的重量即可，看能否成立</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n)</span>, <span class="title">e</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i] &gt;&gt; e[i];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i] &gt;= s[<span class="number">0</span>] &amp;&amp; e[i] &gt;= e[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (ok ? s[<span class="number">0</span>] : <span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Chips-on-the-Board">B. Chips on the Board</h2><p>现在有一个 n * n 的方格， 我需要从中选取一些方格，使得对于每一个方格，它所在的行或者列都至少有一个方格被选了</p><p>每一行或者每一列都有一个代价，选一个方格将加上这一行的代价和这一列的代价值</p><p>求最小代价</p><p><strong>思路：</strong></p><p>要不然每行选一个，要不然每列选一个</p><p>每行选一个的时候，都位于最小代价的列即可；每列同理</p><p>选两个中更小的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    LL sa = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mina = <span class="number">1E9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        sa += a;</span><br><span class="line">        mina = <span class="built_in">min</span>(mina, a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL sb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minb = <span class="number">1E9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        sb += b;</span><br><span class="line">        minb = <span class="built_in">min</span>(minb, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="built_in">min</span>(sa + <span class="number">1LL</span> * n * minb, sb + <span class="number">1LL</span> * n * mina);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Make-it-Alternating">C. Make it Alternating</h2><p>有一个01串，需要经过多次删除操作，使得最后相邻的都不一样</p><p>求操作次数，以及操作方案数(每次删除两个不同位置的数算做不同方案)</p><p><strong>思路：</strong></p><p>操作次数：每个(连续段长度 - 1)</p><p>操作方案：要删的数，直接是阶乘，因为顺序随便。保留的数，是每段的长度，选出来一个。这些乘起来就好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    LL ways = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; n; l = r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; n &amp;&amp; s[l] == s[r])</span><br><span class="line">        &#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// len = (r - 1) - l + 1 = r - l</span></span><br><span class="line">        ans += r - l - <span class="number">1</span>; <span class="comment">// len - 1</span></span><br><span class="line">        ways = ways * (r - l) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ans; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ways = ways * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ways &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Sum-of-XOR-Functions">D. Sum of XOR Functions</h2><p>给你一个长度为 $n$ 的数组 $a$ ，由非负整数组成。</p><p>您必须计算 $\sum_{l=1}^{n} \sum_{r=l}^{n} f(l, r) \cdot (r - l + 1)$ 的值，其中 $f(l, r)$ 是 $a_l \oplus a_{l+1} \oplus \dots \oplus a_{r-1} \oplus a_r$（字符 $\oplus$ 表示位向 XOR）。</p><p>由于答案可能非常大，因此请打印它的模数 $998244353$。</p><p><strong>思路：</strong></p><p>经典题</p><p><code>拆位</code></p><p>之后存下来</p><p>!x（即与 x 相反）的前缀异或和的个数</p><p>!x 的前缀异或和的下标之和</p><p>因为只有是 !x 这样 这一段 的异或是 x ^ !x = 1 才有贡献</p><p>同时注意 因为是前缀异或和 所以 s[a] ^ s[b] 的时候</p><p>计算的是 a+1~b 这一段 长度是 b-a</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">LL s1[<span class="number">30</span>][<span class="number">2</span>], s2[<span class="number">30</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// s1[j][!x] 存储了到目前为止，第 j 位为 !x（即与 x 相反）的前缀异或和的个数</span></span><br><span class="line"><span class="comment">// s2[j][!x] 存储了到目前为止，第 j 位为 !x 的前缀异或和的下标之和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        s[i + <span class="number">1</span>] = s[i] ^ a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">30</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = (s[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">            ans = (ans + (i * s1[j][!x] - s2[j][!x]) % mod * (<span class="number">1</span> &lt;&lt; j) % mod) % mod;</span><br><span class="line">            s1[j][x] = (s1[j][x] + <span class="number">1</span>) % mod;</span><br><span class="line">            s2[j][x] = (s2[j][x] + i) % mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">(ABCDEF)</summary>
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    <category term="CF" scheme="https://devilran6.github.io/categories/ICPC/CF/"/>
    
    
  </entry>
  
  <entry>
    <title>CFdiv2_893</title>
    <link href="https://devilran6.github.io/posts/7fd84b65.html"/>
    <id>https://devilran6.github.io/posts/7fd84b65.html</id>
    <published>2023-08-17T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:26.364Z</updated>
    
    
    <summary type="html">(ABCDEF)</summary>
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    <category term="CF" scheme="https://devilran6.github.io/categories/ICPC/CF/"/>
    
    
  </entry>
  
  <entry>
    <title>CFdiv2_892</title>
    <link href="https://devilran6.github.io/posts/8df7bf3.html"/>
    <id>https://devilran6.github.io/posts/8df7bf3.html</id>
    <published>2023-08-13T16:00:00.000Z</published>
    <updated>2024-03-26T02:43:18.229Z</updated>
    
    <content type="html"><![CDATA[<p>change</p><p>过了abc，卡在了d</p><h2 id="A-United-We-Stand">A United We Stand</h2><p>将数组a拆分乘数组b和c，使得满足任意c[i]不是b[j]的因子，b和c中至少存在一个数。</p><p>如果不能输出-1</p><p><strong>法一：</strong></p><p>巧妙构造：</p><p>因为一个大的数不可能是一个小的数的因子，所以我把最大的数(最大的数数量可能有很多个，需要全都放在c里面，因为两个相等的数之间也互为因子)放在c后，其他剩下的数放在b，即构造成功。</p><p>只有当所有的数都是最大的数(也就是a中所有数都相等)，没有数放到b，输出-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赛时代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (maxv == a[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == maxv)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; pos &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n - pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>法二：</strong> from jiangly</p><p>SCC</p><p>如果 x % y == 0，连接一条 x -&gt; y 的有向边。</p><p>一个强连通分量里面的点互相之间都满足 x % y == 0，所以一个强连通分量里面的点需要全放在b或者c里面。</p><p>如果整个图只有一个强连通分量的话，故输出-1</p><p>如果大于一个的话，因为SCC后按照下标递减的顺序就是拓扑排序</p><p>所以 bel[i] == 0 =&gt; 表示的是只有入度没有出度的那个点</p><p>除了这个强连通分量里的点都不是这些点的因子，其他点都只可能是这些点的倍数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SCC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dfn, low, bel;</span><br><span class="line">    <span class="type">int</span> cur, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SCC</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SCC</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">        dfn.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        bel.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        cur = cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = cur++;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : adj[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(y);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bel[y] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dfn[x] == low[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                y = stk.<span class="built_in">back</span>();</span><br><span class="line">                bel[y] = cnt;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[i] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">SCC <span class="title">g</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (a[i] % a[j] == <span class="number">0</span>)</span><br><span class="line">                g.<span class="built_in">addEdge</span>(i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bel = g.<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">if</span> (bel == <span class="built_in">vector</span>(n, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bel[i] == <span class="number">0</span>)</span><br><span class="line">            b.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; b.<span class="built_in">size</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : b)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == b.<span class="built_in">back</span>()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i : c)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == c.<span class="built_in">back</span>()];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-Olya-and-Game-with-Arrays">B Olya and Game with Arrays</h2><p>最小的 + 选 n-1 组中的次小值</p><ul><li>如果最小的不动，那么就是最小的加上其他所有组的次小值</li><li>如果最小的动，这组变成加次小值，最小的移动到的组变成加最小值</li></ul><p>两种情况是等价的</p><p>比赛的时候我是暴力枚举把哪 n-1 行的最小值扔到 另外一行 在加上这一行(包括被扔过来的)的最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赛时代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vm1</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">vm2</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="type">int</span> minv1 = INF, minv2 = INF;</span><br><span class="line"></span><br><span class="line">        a[i].<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &lt; minv1)</span><br><span class="line">            &#123;</span><br><span class="line">                minv2 = minv1;</span><br><span class="line">                minv1 = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[i][j] &lt; minv2)</span><br><span class="line">            &#123;</span><br><span class="line">                minv2 = a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vm1[i] = minv1;</span><br><span class="line">        vm2[i] = minv2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minv = vm1[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">            &#123;</span><br><span class="line">                res = res + (LL)vm2[j];</span><br><span class="line">                minv = <span class="built_in">min</span>(minv, vm1[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        res = res + (LL)minv;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     cerr &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; vm1[i] &lt;&lt; &#x27; &#x27; &lt;&lt; vm2[i] &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>from jiangly</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min1 = <span class="number">1E9</span>;</span><br><span class="line">    <span class="type">int</span> min2 = <span class="number">1E9</span>;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">        a.<span class="built_in">resize</span>(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; a[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">nth_element</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">        min1 = <span class="built_in">min</span>(min1, a[<span class="number">0</span>]);</span><br><span class="line">        min2 = <span class="built_in">min</span>(min2, a[<span class="number">1</span>]);</span><br><span class="line">        ans += a[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans -= min2;</span><br><span class="line">    ans += min1;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Trick</strong></p><p>nth_element(a.begin(), a.begin() + x, a.end())</p><p>作用是将第(x + 1)小的数放在a[x]上</p><p>并且满足</p><p>a[0] ~ a[x - 1]  &lt;= a[x] &lt;= a[x] ~ a[n - 1]</p><p>所以</p><p>nth_element(a.begin(), a.begin() + 1, a.end())</p><p>将第二小的数放到了a[1]</p><p>进而a[0]只能为最小的数</p></blockquote><h2 id="C-Another-Permutation-Problem">C Another Permutation Problem</h2><p>求n的全排列中，以下式子的最大值</p><p>$(\sum_{i=1}^{n}p_{i}*i)-(max_{j=1}^{n}p_{j}*j)$</p><p><strong>法一</strong>：打表</p><p>发现最优解是将某个后缀翻转，形如{1, 2, k,…,n, n - 1,…,k + 1}</p><p>枚举翻转长度即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        LL maxv = i * i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += (LL)j * j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxv = i * i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>, k = n; j &lt;= n; j++, k--)</span><br><span class="line">        &#123;</span><br><span class="line">            res += (LL)j * k;</span><br><span class="line">            maxv = <span class="built_in">max</span>(maxv, (LL)j * k);</span><br><span class="line">        &#125;</span><br><span class="line">        res -= maxv;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, res);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>法二</strong>：from jiangly</p><p>暴力 and 并查集</p><p>枚举$(max_{j=1}^{n}p_{j}*j)$的值，进行限制。</p><p>之后从第n位开始填，尽可能填大的数。</p><p>并查集的用于维护的是，如果我现在这个位置上可以填的最大的数是x,但是x已经被填过了。</p><p>因为在x填的时候让p[x]=x-1,所以find(x)会从x向更小的数找x-1,x-2…直到第一个没有填的数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f, siz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x])</span><br><span class="line">        &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = n * n;; l--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">DSU <span class="title">dsu</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = dsu.<span class="built_in">find</span>(<span class="built_in">min</span>(n, l / i));</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 表示已经开始无法满足了</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += i * x;</span><br><span class="line">            dsu.<span class="built_in">merge</span>(x - <span class="number">1</span>, x); <span class="comment">// p[x] = x - 1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ok)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum - l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-Andrey-and-Escape-from-Capygrad">D Andrey and Escape from Capygrad</h2><p>发现对于 l r a b</p><p>l到b的数都会跳到b，b到r的数不会动</p><p>故a和r是两个没有用的数，将所有线段的[l, b]，区间合并即可</p><p>之后二分找第一个大于x的r即可</p><p>from jiangly</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; <span class="built_in">seg</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, a, b;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        seg[i] = &#123;l, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(seg.<span class="built_in">begin</span>(), seg.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [l, r] : seg)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a.<span class="built_in">empty</span>() &amp;&amp; l &lt;= a.<span class="built_in">back</span>()[<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(a.<span class="built_in">back</span>()[<span class="number">1</span>], r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="built_in">lower_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), array&#123;x + <span class="number">1</span>, <span class="number">0</span>&#125;) - a.<span class="built_in">begin</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">max</span>(x, a[j][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot; \n&quot;</span>[i == q - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-Maximum-Monogonosity">E Maximum Monogonosity</h2><p>DP</p><p>题目：</p><p>给两个长度均为 n 的数组 a, b</p><p>对选取 [l, r] 一段</p><p>长度为 $r-l+1$</p><p>价值为 $\lvert a_l - b_r \rvert + \lvert a_r - b_l \rvert$</p><p>选取总长度为 k 的段，每个段都互不相交，求最大总价值</p><p>法一：</p><p>暴力dp + 剪枝</p><p>$dp[i][j]$ 表示的是前i个字符，还需要总长度为j的片段的最大价值</p><p>**第一个循环：**i</p><p>枚举到第i个点</p><p>**第二个循环：**len</p><p>枚举最后一段的长度，即枚举是从哪个点转移过来</p><p>最后一段即为 [i-len+1, i]</p><p>**第三个循环: **z</p><p>枚举除去这段前，仍需要的段的总长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= i; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> st = i - len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> z = len; z &lt;= k; z++)</span><br><span class="line">        &#123;</span><br><span class="line">        dp[i][z - j] = <span class="built_in">max</span>(dp[i][z - j], dp[st - <span class="number">1</span>][z] + + (LL)<span class="built_in">abs</span>(a[st] - b[i]) + <span class="built_in">abs</span>(a[i] - b[st])));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为dp[i][j] 表示的是前i个字符，还需要总长度为j的片段</span></span><br><span class="line">    <span class="comment">// 而每次上面的循环计算出来的dp[i][j]都是i这个点在目前的最后一段里的</span></span><br><span class="line">    <span class="comment">// 所以需要把i这个点不在目前的最后一段里的也max以下</span></span><br><span class="line">    <span class="comment">// 这个值就是dp[i - 1][j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;LL&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;LL&gt;(m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">1</span>; len &lt;= i; len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> st = i - len + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> z = <span class="built_in">max</span>(len, m - (st - <span class="number">1</span>)); z &lt;= <span class="built_in">min</span>(m, n - (st - <span class="number">1</span>)); z++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][z - len] = <span class="built_in">max</span>(dp[i][z - len], dp[st - <span class="number">1</span>][z] + (LL)<span class="built_in">abs</span>(a[st] - b[i]) + <span class="built_in">abs</span>(a[i] - b[st]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><p>标准解法</p><p>参考</p><p><a href="https://www.cnblogs.com/szdytom/p/how-did-we-get-here-2.html">https://www.cnblogs.com/szdytom/p/how-did-we-get-here-2.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/649682355">https://zhuanlan.zhihu.com/p/649682355</a></p><p>首先拆开绝对值</p><p>将对于$\lvert a_l - b_r \rvert + \lvert a_r - b_l \rvert$的维护转化成</p><p>对于$/+a_l + b_l/+a_l - b_l/-a_l + b_l/-a_l - b_l/$这四个值的维护</p><p>同时维护两个数组dp mx</p><p>mx数组更新的是选择第一个点，即每一段的左端点</p><p>dp数组更新的是选择第二个点，即每一段的右端点</p><p>$dp[i][j]$：表示前i个点，选的段的总长度为j</p><p>$mx[u][id]$：u表示是拆分出来的四个式子中的哪一个，id表示i-j的值为多少</p><p>因为每次选一段 [l, r] 长度 len 后</p><p>i变成ii=i+len，j变成jj=j+len，会发现一件神奇的事情是i-j==ii-jj</p><p>所以每次转移的时候i-j的值是固定的</p><p>可以按照i-j的大小进行分类转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULL unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="type">const</span> LL INF = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line">LL mx[<span class="number">4</span>][N];</span><br><span class="line">LL dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> s2[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">2</span>)</span>, <span class="title">b</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> get = [&amp;](<span class="type">int</span> x, <span class="type">int</span> id, <span class="type">int</span> u) -&gt; LL</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[x][x - id] + a[x + <span class="number">1</span>] * s1[u] + b[x + <span class="number">1</span>] * s2[u];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            mx[i][j] = -INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        mx[u][<span class="number">0</span>] = <span class="built_in">get</span>(<span class="number">0</span>, <span class="number">0</span>, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="built_in">min</span>(k, i); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> id = i - j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i][j], mx[u][id] - s1[u] * b[i] - s2[u] * a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">4</span>; u++)</span><br><span class="line">            &#123;</span><br><span class="line">                mx[u][id] = <span class="built_in">max</span>(mx[u][id], <span class="built_in">get</span>(i, id, u));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][k] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ABCDE(F)</summary>
    
    
    
    <category term="ICPC" scheme="https://devilran6.github.io/categories/ICPC/"/>
    
    <category term="CF" scheme="https://devilran6.github.io/categories/ICPC/CF/"/>
    
    
  </entry>
  
</feed>
